\section{Research activities}
\label{sec:research}

\extended{\cite{huang2018real}, \cite{gang2018throughput}, \cite{zhong2018improving}, \cite{basuki2019assuring}, \cite{spinelli2019chaining}, \cite{long2019scalable}, \cite{van2019rp1}, \cite{basuki2018sub}, \cite{jadin2019cg4sr}, \cite{wang2019segment}, \cite{li2019traffic}, \cite{liu2019load}, \cite{ch2018sdn}, \cite{yang2019qoe}, \cite{pereira2018segment}, \cite{roomisemi}, \cite{dominicini2019keysfc}, \cite{xie2019mitigating}, \cite{lacan2020xor}, \cite{li2020pasr}}

In this section, we describe the research activities on SR, and we provide two different classifications to characterize the research papers on the basis of their main scope. We also show how to extract useful information regarding the ongoing SR research activity from analyzing the relationship among the two classifications proposed.

The first classification proposed is based on the identification of seven main \emph{Research Categories}, as reported in Table~\ref{tab:res-taxonomy}.
The first one is the \emph{Monitoring} category, collecting all the works that describe and implement tools related to network monitoring activities.
Some example are the measurements of the end to end delay over a given input route or the assessment of the volume of the traffic flows.
The second category is \emph{Traffic Engineering}, where we include all the works proposing advanced routing strategies to optimize the network performances.
The third category is \emph{Failure Recovery}, covering solutions to provide fast network recovery in the case of node/link failure; due to the time scale constraints, the works in this category are based on local mechanisms, i.e. not involving the central controller.
The fourth category defined is \emph{Centrally Controlled Architectures}, including all the papers focusing on the implementation of an SR network with a centralized control plane realized on top of an underlay network (IP, SDN, MPLS). Here we point out that, despite some of the works classified as \emph{Traffic Engineering} are based on a centrally controlled architectures, they are not included in the \emph{Centrally Controlled Architectures} category, since their main scope remains to optimize a TE goal (such the reduction of the congestion, or the minimization of the energy consumption).
In the \emph{Path Encoding} category we group all the papers that propose algorithms aiming at translating network paths into an SL; specifically, taking as input a path in the form of a sequence of nodes and links, the generic path encoding algorithm provides as output a sequence of SIDs to be pushed in the packet header, so that to steer the packet along the input path.
The sixth category is \emph{Network Programming}, where we inserted the scientific works that propose solutions that exploit the programmability feature of SR. i.e. using service based SIDs to define the functions to be executed on packets crossing a specific segment list. A significant example of works falling into this category, are all the ones related to Service Function Chaining.  
Finally, we define a \emph{Miscellaneous} category, where we put all the works not belonging to previous categories.

%discuss Table~\ref{tab:classification} Fig.~\ref{fig:taxonomy12b} and Fig.~\ref{fig:taxonomy12} ... clarify that in this classification a paper can appear more than once

\begin{table}
\centering
\caption{\\Classification \#1 based on research categories}
\label{tab:res-taxonomy}
\begin{tabular}{|l|c|}
\hline
\multicolumn{1}{|c|}{\textbf{Category}}                                               & \textbf{References} \\ \hline
\textit{Monitoring (MON)}                                                                   & \cite{interoperable,scmon,li2018bandwidth,li2018ilp,polverini2018routing,cianfrani2018heuristic,polveriniNoF2018,xhonneux2018leveraging} \\ \hline
\textit{Traffic Engineering (TE)}                                                          & \cite{anefficient,novelsdn,ascalableand,energyefficient,ghuman2017per,trafficpmsr,ontraffic,optimizedte,roomi2018semi,defo1,gay2017expect,defo2,incrementaldeploy,moreno2017traffic,pereira2017optimizing,barakabitze2018novel,pang2017sdn,dugeon2017demonstration,hou2019optimization,settawatcharawanit2018segment,trimponias2019node,zhang2019bandwidth} \\ \hline
\textit{Failure Recovery (FR)}                                                             & \cite{timfa,trafficduplication,aubry2018robustly,optimizingrestoration,segmentfor,srdynamicrestoration,reliablesr,xhonneux2018flexible,foerster2018local} \\ \hline
\textit{\begin{tabular}[c]{@{}l@{}}Centrally Controlled\\ Architectures (CCA)\end{tabular}} & \cite{firstdemonstration,sdnandpce,paolucci2018network,paolucci2017service,castoldi2017segment,springopen,fressancourt2015sdn,li2017segment,lebrun2018software,duchene2018exploring,ventre2018sdn,demonstrationofsr,experimentalmulti,evolve,barakat2019busoni,eramo2019effectiveness} \\ \hline
\textit{Path Encoding (PEN)}                                                                & \cite{experimentaldemonstration,efficientlabel,pathencoding,labelencoding,pmsr,translating,liaoruo2018optimizing,guedrez2017new} \\ \hline
\textit{Network Programming (NP)}                                                          & \cite{srv62,17-vnf-chaining-sr,duchene2018srv6pipes,abdelsalam2018sera,srlb,desmouceaux2019content,desmouceauxzero,mayer2019efficient} \\ \hline
\textit{Performance Evaluation (PEV)}                                                                & \cite{ahmedperformance,teamsegment,leeperformance,abdelsalam2020srperf} \\ \hline
\textit{Miscellaneous (MISC)}                                                                & \cite{abdullah2018segment,cxp,pathlet,scalablesegment1,scalablesegment2,scalablesegment3,schuller2018practical,chi2018live,cao-industrial-iot,mayer-network-as-computer} \\ \hline
\end{tabular}
\end{table}

\begin{figure}
    \centering
    \includegraphics[trim=4cm 1.2cm 4cm 1cm,clip, width=1\columnwidth]{fig/taxonomy1-new.pdf}
    \caption{Number of references for each category of the defined taxonomy.}
    \label{fig:taxonomy1}
    %\vspace{-3ex}
\end{figure}

In Fig.~\ref{fig:taxonomy1} we report an histogram showing the number of references falling into each of the defined categories.
Analyzing Fig.~\ref{fig:taxonomy1}, it is evident that \emph{Traffic Engineering} and \emph{Centrally Controlled Architectures} are the most investigated subjects, while the other categories have been covered by almost the same number of works.
This behavior is quite expected since the main feature of SR is to define routing paths in a very flexible way and to make use of widely deployed data planes; this aspect is really appealing for the definition of new solution to TE problems and for the realization of overlay networks.
On the contrary, the number of papers related to \emph{Network Programming} could suggest a low interest of the research community to such a novel topic. We believe that \emph{Network Programming} represents a higly interesting research topic for next future, and that the lower number of available papers is only due to its early definition state.

In order to better investigate the research activity related to SR, we propose a second classification based on the specific SR topics considered in the research works. The new SR-related classification is reported in Tab.~\ref{tab:classification}. The different SR topics are also aggregated in three main groups:
\begin{itemize}
    \item SR feature exploitation;
    \item SR functions optimization;
    \item SR extensions.
\end{itemize}

The \emph{SR feature exploitation} group covers all the works making use of SR features to solve classical networking problems, such as network resource optimization and performance improvement. The first SR topic is the \emph{routing flexibility}, i.e., the possibility of steering a packet over a non trivial path (e.g., containing ECMP, loops, ect.).
The second feature is the \emph{source routing}, i.e. the capability of SR to instruct only the source node for the configuration of a specific network path.
The third SR feature is the \emph{programmability}, i.e., the possibility to force a packet to go through a function by using specific SIDs.
All the remaining SR features are included in the \emph{other} topic.
We merged here together the following topics: i) the Adj-SIDs, used to force a packet to be forwarded on a specific output port; ii) the ECMP, i.e. the ability of SR to balance the traffic over multiple paths provided by the IGP routing protocols; iii) the Type Length Value (TLV) used to add optional data to the SR header; iv) the Binding SID (BSID) that allows to define SR tunnels in a transit node; v) the SR traffic counters \revnew{(Base Pcounters and TM Pcounters)}, which collect traffic statistics based on the active segment carried in the packets headers; and vi) the spray policy, which allows to duplicate an incoming packet over multiple output port and using different SLs. 

In the \emph{SR functions optimization} group, the research activities aiming at improving the inner functions of an SR network, are inserted.
The first topic of the group is the \emph{SR Steering Policy}, i.e. the definition of policies to be installed on the network devices in order to attach the proper SL to each incoming packet. The second topic is  the \emph{SL length}, i.e. the number of SIDs of a segment list, that has an impact on SR header insertion and processing.

The last group, i.e. \emph{SR extensions}, is represented by a single topic (\emph{new functions}) and is related to new functionality implemented in SR to support advanced services.

Tab.~\ref{tab:classification} reports the classification of the research works according to the SR topics. Differently than Tab.~\ref{tab:res-taxonomy}, where the same reference can appear only once, in Tab.~\ref{tab:classification}, it can be classified under different categories. As a matter of example, \cite{translating} uses the \emph{Adj-SIDs} SR feature in order to perform \emph{SR functions optimization} from the point of view of \emph{SL length}.


\begin{table*}
\caption{\\Classification \#2 based on SR topics}
\label{tab:classification}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multicolumn{4}{|c|}{\textbf{SR feature exploitation}}                                                                                                                                                                                                                                     & \multicolumn{2}{c|}{\textbf{SR functions optimization}}                                                                               & \textbf{Extend SR}                            \\ \hline
\multicolumn{1}{|c|}{\textit{Routing Flexibility}} & \textit{Source Routing}                                                        & \textit{Programmability}                                       & \textit{Others}                                                            & \multicolumn{1}{c|}{\textit{SR steering policy}}      & \textit{SL length}                                                     & \multicolumn{1}{c|}{\textit{New Functions}}   \\ \hline
\begin{tabular}[c]{@{}c@{}}\cite{scmon},\cite{polverini2018routing},\cite{cianfrani2018heuristic},\cite{novelsdn}\\ \cite{energyefficient},\cite{ghuman2017per},\cite{ontraffic},\cite{defo1}\\ \cite{gay2017expect},\cite{moreno2017traffic},\cite{hou2019optimization},\cite{settawatcharawanit2018segment}\\
\cite{trimponias2019node,eramo2019effectiveness,zhang2019bandwidth}\end{tabular}  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\cite{interoperable},\cite{scmon},\cite{li2018bandwidth}\\
\cite{li2018ilp},\cite{anefficient},\cite{novelsdn}\\
\cite{ascalableand},\cite{trafficpmsr},\cite{optimizedte}\\
\cite{roomi2018semi},\cite{defo1},\cite{gay2017expect}\\
\cite{incrementaldeploy},\cite{pereira2017optimizing},\cite{barakabitze2018novel}\\
\cite{pang2017sdn},\cite{dugeon2017demonstration},\cite{segmentfor}\\
\cite{firstdemonstration},\cite{sdnandpce},\cite{paolucci2018network}\\
\cite{paolucci2017service},\cite{castoldi2017segment},\cite{springopen}\\
\cite{fressancourt2015sdn},\cite{li2017segment},\cite{lebrun2018software}\\
\cite{duchene2018exploring},\cite{demonstrationofsr},\cite{experimentalmulti}\\
\cite{evolve}\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\cite{mayer2019efficient},\cite{xhonneux2018leveraging},\cite{xhonneux2018flexible},\cite{srv62}\\\cite{17-vnf-chaining-sr},\cite{duchene2018srv6pipes},\cite{abdelsalam2018sera}\\\cite{srlb},\cite{desmouceaux2019content}\\
\cite{desmouceauxzero}\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\textbf{BSID:}\cite{timfa},\cite{foerster2018local},\cite{lebrun2018software},\cite{duchene2018exploring},\cite{experimentalmulti}\\\cite{eramo2019effectiveness}\\ \textbf{ECMP:}\cite{optimizedte},\cite{moreno2017traffic},\cite{pereira2017optimizing}\\ \textbf{TLV:}\cite{xhonneux2018leveraging},\cite{timfa},\cite{xhonneux2018flexible},\cite{sdnandpce}\\ \textbf{Adj-SID:}\cite{pmsr},\cite{incrementaldeploy},\cite{efficientlabel},\cite{labelencoding},\cite{translating}\\ \textbf{Spray:}\cite{trafficduplication},\cite{aubry2018robustly}\\ \textbf{Traffic counters:}\cite{polveriniNoF2018}\end{tabular}} & \begin{tabular}[c]{@{}c@{}}\cite{ascalableand},\cite{gay2017expect},\cite{incrementaldeploy}\\ \cite{liaoruo2018optimizing},\cite{guedrez2017new}\end{tabular} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\cite{pmsr},\cite{anefficient}\\ \cite{trafficpmsr},\cite{incrementaldeploy}\\ \cite{moreno2017traffic},\cite{dugeon2017demonstration}\\ \cite{hou2019optimization},\cite{experimentaldemonstration}\\
\cite{efficientlabel},\cite{pathencoding}\\
\cite{labelencoding},\cite{translating}\\ \cite{liaoruo2018optimizing},\cite{guedrez2017new}\end{tabular}} & \begin{tabular}[c]{@{}c@{}}\cite{pmsr}, \cite{xhonneux2018leveraging}\\ \cite{segmentfor},\cite{srdynamicrestoration}\\ \cite{reliablesr},\cite{guedrez2017new}\\ \cite{abdelsalam2018sera},\cite{desmouceauxzero}\end{tabular} \\ \hline
\end{tabular}
\end{table*}

Tab.~\ref{tab:classification} shows that the most used SR feature is the \emph{source routing} one, while there is still a limited amount of works focusing on \emph{network programmability} and on the definitions of \emph{new functions}.

\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{fig/taxonomy_1-2b-new.pdf}
    \caption{Graph showing the relation between the research categories and the SR topics.}
    \label{fig:taxonomy12}
    %\vspace{-3ex}
\end{figure}

In order to obtain further insights about the SR research activity, we defined a way to show the relationship between the classifications reported in Tab.~\ref{tab:res-taxonomy} and Tab.~\ref{tab:classification}, respectively. In Fig.~\ref{fig:taxonomy12} we report a graph, defined in the following way: each node represents a research category (violet rectangles at the center of the figure) or an SR topic (divided in red, blue and green rectangles at the border of the figure), and an edge among a category and an SR topic is present only if both are present in the same work. Moreover, the thickness of an edge depends on the number of papers covering the specific category/topic pair. The graph reported in Fig.~\ref{fig:taxonomy12} shows several interesting outcome: i) the works related to the \emph{Monitoring} category mainly exploit the routing flexibility and the source routing paradigm; ii) a same result is obtained for the \emph{Traffic Engineering} works, but in this case also the SR steering policy and SL length topics are covered; iii) in order to provide \emph{Failure Recovery} solutions, new functions generally need to be defined; iv) the source routing is the most used SR feature for \emph{Centrally Controlled Architecture} solutions, since it allows to reduce the communication between the central controller and the network devices; v) as expected, the \emph{Path Encoding}  works are mainly focused on the optimization of the SL length (it is anyway interesting to notice that the Adj-SID is the main SR feature used to get this scope); vi) finally, works falling in the \emph{Network Programming} category always exploit the programmability feature of SR, and, in some cases, new functions need to be defined.

\begin{figure}
    \centering
    \includegraphics[trim=4cm 1.2cm 4cm 1cm,clip, width=1\columnwidth]{fig/taxonomy_1-2c-new.pdf}
    %\[trim=left bottom right top, clip]
    \caption{Histogram showing the relation between the Classifications defined in Tab.~\ref{tab:res-taxonomy} and Tab.~\ref{tab:classification}.}
    \label{fig:taxonomy12b}
    %\vspace{-3ex}
\end{figure}

In Fig.~\ref{fig:taxonomy12}, we report for each category/SR topic the number of related references.

In the next subsections we briefly describe all the research works, considering the classification proposed in Tab.~\ref{tab:res-taxonomy}.

\subsection{Monitoring}
\label{sec:mon}

\MonitoringPapers research works proposing monitoring solutions able to exploit SR have been defined, as shown in Table \ref{tab:monitoring}. These works have been classified on the basis of their main aim:
\begin{itemize}
    \item \emph{delay measurements}, aiming at obtaining the delay for links and routers exploiting the possibility of modifying the SL at source nodes, i.e. source routing SR feature;
    \item \emph{health checking of network devices}, aiming at monitoring the network state exploiting the capability of SR in defining ad-hoc routes, i.e. routing flexibility feature.
    \item \emph{traffic measurements}, aiming at assess the traffic matrix of a network exploiting routing flexibility and SR counters;
    \item \emph{traceroute}, aiming at implementing the well known traceroute utility in SR.
\end{itemize}

\begin{table}
\centering
\caption{\\Classification of the references related to Monitoring.}
\label{tab:monitoring}
\begin{tabular}{|c|c|}
\hline
\textbf{Objective}                                                                         & \textbf{References} \\ \hline
\textit{\begin{tabular}[c]{@{}c@{}}Delay measurements\end{tabular}} & \cite{interoperable},\cite{xhonneux2018leveraging} \\ \hline
\textit{\begin{tabular}[c]{@{}c@{}}Health checking \\ of network devices\end{tabular}}    & \cite{scmon},\cite{li2018bandwidth},\cite{li2018ilp} \\ \hline
\textit{Traffic measurements}                                                              & \cite{polverini2018routing},\cite{cianfrani2018heuristic},\cite{polveriniNoF2018} \\ \hline
\textit{Traceroute}                                                                        & \cite{xhonneux2018leveraging} \\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as monitoring related works.

\cite{interoperable} proposes a novel monitoring system powered by Segment Routing (SR) which is used for the provisioning of delay-aware network services spanning multiple-domains. Based on SR-MPLS principles, it enables the delay measurements over multiple candidate routes without requiring related LSP signalling sessions. The authors consider two types of probes using SR-MPLS. The first type is originated and terminated by network stations and allows to retrieve only round-trip measurements and they have less accuracy. Moreover they are typically used for performance measurements over a single link. Instead, the second type relies on external monitoring components which inject and receive timestamped probes routed according to the enforced SR segment list. The second type of measurements requires synchronization between the end-points but allows to measure also unidirectional delay which are more useful when it is necessary to deploy services in the network. \revnew{The project shares with most of the related works the objective of the reduction of the control plane complexity through SR. However from the paper is not clear which implementation the authors used for SR or if they relied on any vendor solution.}

The traffic steering capabilities of SR have been used in SCMon \cite{scmon}, a new solution for continuous monitoring of the data-plane. It allows to track the health of all routers and links: i) forcing ``monitoring probes to travel over cycles''; and (ii) testing ``parallel links and bundles at a per-link granularity''. The key insight is that network nodes compute a second network graph and calculate routes on this monitoring topology which spans all network links. Then, nodes carefully select ECMP paths and enforce packet forwarding through cycles leveraging SR in order to detect/localize failures and overloading of single/multiple links. 
%Going into the details, firstly the weights of IGP monitoring topology are carefully selected in order to guarantee that each link belongs to some shortest paths and the ECMP are minimum as possible. Then the monitoring graph is furthermore transformed removing all the natural ECMP paths created by the links bundles. At this point the cycles cover are computed as a concatenation of shortest paths and then translated as segment list. Author proposes an interesting algorithm which allows to cover all network links with a limited number of SR segments (see Section \ref{sec:path} for more details). 
A prototype implementation of SCMon has been evaluated on publicly available topologies and emulated networks. In the first experiment the ratio number of cycles over number of edges is evaluated to analyze the percentage of the networks covered. Then the authors evaluate the time to detect black holes showing that most of them are detected within less than 100 msec. \revnew{The work results are very interesting and can be applied to real use cases. However, an open-source implementation is not available at the time of writing.}

In \cite{li2018bandwidth}, the authors focus on bandwidth-efficient monitoring schemes based on cycles. They propose four different algorithms to compute cycles which are designed to traverse/cover every link in the network. This optimization based on cycles allows to save network resources and to monitor the network from a single point of advantage. Segment Routing is used as transport technology to forward the probes along the network. The paper builds upon the results of \cite{scmon}: the authors leverage the phase 1 of SCMon to build the monitoring topology of the network and then apply their two-phase algorithms in order to minimize the cycle cover length. 
%The first algorithm is a simple extension of the phase 2 of SCMON, key insight is to stop cycle computation when the current node is the source or when all the links are covered. In this way it is possible to create shortest segment lists. Second algorithm leverages symmetry property of the network to routing back in an efficient way to the source. Basically, it leverages the same links already reserved on the way back. The third algorithm introduces a new path metric to select which path should be chosen first based on the net coverage (percentage of links already covered by a cycle) of its links. The fourth algorithm improves the previous one with the introduction of parallel and sequential cycles which are built leveraging the number of times $x$ the source node is visited during the cycle. Firstly, this allows to compute $x$ parallel cycles and then from this it is possible to create sequential cycles in incremental way to cover the remaining links. 
Performance evaluation shows the effectiveness of these algorithms in terms of cycle cover length and segments list depth and the improvements respect to the baseline (SCMon). 
%Finally, the four two-phase algorithms are enhanced to work without a monitoring topology. Experiments show that the cycle cover length is slightly increased, however the cost saving due to removing the maintenance of the monitoring topology is more significant.

\revnew{Instead, \cite{li2018ilp} extends \cite{li2018bandwidth} proposing three ILP formulations for the construction of the monitoring-cycles. A first ILP formulation solves optimally the problem of covering every link in the network using monitoring-cycles with minimum cycle cover length. To further conserve network bandwidth, the first formulation is extended to jointly minimize the total segment list size needed. Finally, since the time required to detect a network failure is affected by the longest cycle, the first formulation is also extended to jointly minimize the length of the longest cycle.}

\cite{polverini2018routing} exploits the flexibility of SR to perform traffic measurements and get the Traffic Matrix.
A traffic measurement is performed by rerouting a flow and checking the load variations caused on the network links.
Even though the idea of measuring traffic through routing perturbations is not new, SR turns out to be an enabling technology for the applicability of such an approach.
In fact, while in the past traffic flows were rerouted by acting on the OSPF link weights, causing routing instability and performance degradation, SR allows to modify a path by simply acting on the ingress node, then reducing the impact of a rerouting.
In \cite{polverini2018routing}, the problem of assessing the TM while minimizing the routing perturbations is formulated as an ILP and an heuristic algorithm called SERPENT is presented.
%SERPENT is an iterative algorithm that, at each iteration, tries to maximize the number of measured flows while taking into account the link capacity constraint.
%This last aspect is not straightforward, since it would require the knowledge of the TM, which is the target of the algorithm.
%To overcome the lack of such an information, SERPENT relies on a Traffic Oblivious model, that allows to ensures the respect of the capacity constraint without the TM knowledge.
Due to the high computational complexity of SERPENT, a lighter greedy heuristic called PaCoB is proposed in \cite{cianfrani2018heuristic}.

An attractive feature of SR is the introduction of specific interface counters that allow to get statistics on network traffic flows. \revnew{If this feature is included in the hardware design of the router, the update of the traffic counters can be associated with the normal processing in the SR data plane, thus having a negligible impact on the router performance.}
The simplest type of SR counters, named Base Pcounters, collect traffic statistics (byte/packets) passing through a router and having a specific active segment.
Enhanced SR counters, named TM (Traffic Matrix) Pcounters, allow to distinguish between traffic that is internal to the SR domain and flows that are injected into the SR domain.
Specifically, a TM Pcounter collects traffic statistics of traffic flows received by an interface marked as external (this is a configuration option for the network operator).
\revnew{Since TM Pcounters can discriminate packets on the basis of the incoming interface, using TM Pcounters provides a thinner granularity with respect to using Base Pcounters and facilitates the estimation of the Traffic Matrix.}
Starting from the availability of this new type of traffic related information, in \cite{polveriniNoF2018} the Traffic Matrix Assessment problem has been extended to include the SR counters measurements. The authors show that, depending on the structure of the Segment Lists used in the network, the Traffic Matrix can be assessed with no error.

\cite{xhonneux2018leveraging} extends the Linux kernel to run eBPF programs as in-network functions attached to the SRv6 SIDs; further details about the implementation are provided in the Section \ref{sec:tools}. The authors demonstrate the effectiveness of their approach building three different applications. The first one realizes a passive monitoring solution of network delays (direct links or end-to-end paths) \cite{id-udp-pm}. The high level idea is that a small percentage of traffic is encapsulated with a special SRH carrying on additional information like timestamps. These timestamps are then used by the recipient nodes to calculate one-way or round-trip delays. 
%Performance evaluation shows that eBPF programs used to implement these functionalities introduce a negligible overhead. 
The second application realizes a link aggregation group using SRv6. In particular a weight-round-robin scheduling is realized to aggregate the bandwidth of two different links. Finally, an enhanced version of traceroute has been realized implementing a new SRv6 behavior, the so called \textit{End.OAMP}. This behavior when triggered performs a \textit{fib lookup} in the node and return to a destination address specified in the SRH all the ECMP next hops. If possible this function is leveraged at each hop, otherwise the program falls back to the legacy ICMPv6 mechanism.

\revnew{In the following we provide a comparison among the works classified in the \emph{Monitoring} category.}

\revnew{Regarding the solutions related to delay measurements, both of them (\cite{interoperable} and \cite{xhonneux2018leveraging}) allow to get the one-way end to end delay between two points in the network. While the former requires the use of an external monitoring tool to generate timestamped probes (the use of SR is limited to the creation of the end to end path), the latter does not. Anyway, \cite{xhonneux2018leveraging} is suitable only for networks realized by means of Linux based SRv6 routers, since it exploits the definition of eBPF programs to perform the measurement.}

\revnew{There are two SR based monitoring tools for checking the health status of the network links (\cite{scmon} and the one proposed in \cite{li2018bandwidth} and \cite{li2018ilp}). The approach they follow is similar, i.e., the creation of cyclic paths through SR where to send probe messages. With respect to \cite{scmon}, \cite{li2018bandwidth} and \cite{li2018ilp} optimize the use of the monitoring resources needed to check the status of all the network elements. Anyway, \cite{li2018bandwidth} and \cite{li2018ilp} do not support link bundles, while \cite{scmon} does.}

\revnew{Among the Traffic measurement tools based on SR, two different approaches can be identified in \cite{polverini2018routing,cianfrani2018heuristic, polveriniNoF2018}. The first approach aims at measuring traffic flows by causing link load variation through re-routing operations. This is exploited in \cite{polverini2018routing,cianfrani2018heuristic}. The second approach is based on the use of specific traffic counters, available in SR enabled nodes. This is exploited in \cite{polveriniNoF2018}. While both approaches allow to get comparable performances in terms of the quality of the assessed Traffic Matrix, the counter based solution does not affect the network performance, differently from the to re-routing based solutions.}

\subsection{Traffic Engineering}
\label{sec:te}
Due to its appealing features in terms of routing flexibility, SR is widely used to face Traffic Engineering related problems.
During our investigation, we have found \tePapers papers exploiting SR to provide advanced TE solutions.
The TE research works have all the classical structure of an optimization problem: i) an objective function must be minimized/maximized, ii) taking into account a set of parameters, and iii) considering a specific network scenario.
Three different TE objectives have been covered by the literature, i.e., the minimization of the network energy consumption, the optimization of the congestion and the minimization of the number of rejected requests.
The high routing flexibility allowed by SR might cause the presence of complex and long network paths.
For this reason, while optimizing the routing according to the specific objective, it is important to take into account the impact that excessively complex routing solutions might have on the network performance.
Further than the end to end delay, some of the reviewed works also take into account SR related overhead, both in terms of bandwidth wasted due to the insertion in the packets of the SR header, and the number of SR steering policy to be configured in the edge routers.
Finally, the considered network can be a full SR one, i.e., all the nodes are SR capable, or a partially deployed SR, where only a subset of nodes can process the SR header.

Table \ref{tab:TE} show the classification of the TE related references.
It is interesting to notice that most of the works consider the congestion minimization as main objective, and that there are few solutions that can work also in a hybrid network scenario.

\begin{table}
\centering
\caption{\\Classification of the references related to Traffic Engineering.}
\label{tab:TE}
\begin{tabular}{|c|l|c|}
\hline
\multirow{3}{*}{\textbf{Objective}}                                                    & \textit{\begin{tabular}[c]{@{}l@{}}Energy\\ Consumption\end{tabular}}               & \cite{energyefficient},\cite{ghuman2017per} \\ \cline{2-3} 
                                                                                       & \textit{Link Bandwidth}                                                             & \begin{tabular}[c]{@{}c@{}}\cite{anefficient}, \cite{novelsdn},\cite{ascalableand},\cite{trafficpmsr},\cite{ontraffic} \\ \cite{optimizedte},\cite{roomi2018semi},\cite{defo1},\cite{gay2017expect},\cite{incrementaldeploy}\\ \cite{moreno2017traffic},\cite{pereira2017optimizing},\cite{barakabitze2018novel},\cite{pang2017sdn},\cite{dugeon2017demonstration}\\         \cite{hou2019optimization},\cite{settawatcharawanit2018segment}\cite{trimponias2019node},\cite{zhang2019bandwidth}\end{tabular} \\ \cline{2-3} 
                                                                                       & \textit{Rejected Requests}                                                          & \cite{anefficient},\cite{defo1}                                                   \\ \hline
\multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Takes into\\ account\end{tabular}}} & \textit{Delay}                                                                      & \cite{novelsdn},\cite{defo1},\cite{dugeon2017demonstration},\cite{hou2019optimization} \\ \cline{2-3} 
                                                                                       & \textit{\begin{tabular}[c]{@{}l@{}}SR impact\\ (overhead, flow state)\end{tabular}} & \begin{tabular}[c]{@{}c@{}} \cite{anefficient},\cite{ascalableand},\cite{incrementaldeploy},\cite{moreno2017traffic},\cite{pereira2017optimizing} \\ \cite{barakabitze2018novel},\cite{pang2017sdn},\cite{dugeon2017demonstration},\cite{hou2019optimization}\end{tabular} \\ \hline
\multirow{2}{*}{\textbf{Scenario}}                                                     & \textit{Full SR}                                                                    & \begin{tabular}[c]{@{}c@{}}  \cite{anefficient},\cite{ascalableand},\cite{energyefficient},\cite{ghuman2017per},\cite{trafficpmsr}\\  \cite{ontraffic},\cite{optimizedte},\cite{roomi2018semi},\cite{defo1},\cite{defo2} \\  \cite{moreno2017traffic},\cite{barakabitze2018novel},\cite{pang2017sdn},\cite{dugeon2017demonstration},\cite{hou2019optimization}\\ \cite{trimponias2019node} \end{tabular} \\ \cline{2-3} 
                                                                                       & \textit{Partially deployed SR}                                                      & \cite{novelsdn},\cite{incrementaldeploy},\cite{zhang2019bandwidth}                                                   \\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as TE related works.

\cite{anefficient} implements a TE algorithm with SR in a SDN infrastructure which builds path with bandwidth guarantees and minimizes at the same time the possibility of rejecting traffic demands. Respect to other solutions, it takes into account the link ``criticality'' and not only link residual bandwidth. Citing \cite{anefficient}: ``Link criticality is based on the concept of the minimal interference routing method''. It allows to minimize the possibility of rejecting requests when the network becomes overloaded. The proposed algorithm not only achieves the goal of balancing the network traffic load, but it also promises to reduce the network costs. Since it is based on SR principles, the proposed solution also considers the extra network overhead caused by the segment labels in the packet headers. The path length has been modeled as a constraint of the heuristic adopting an extra hop limitation in order to save network resources - extra bandwidth used by the segment lists in the packet headers. \revnew{According to the authors, the time complexity of the algorithm can meet the requirements of dynamic online routing, however there are no open source implementations available and only simulation results are provided by the authors.}

Bahnasse et al. \cite{novelsdn} propose an SDN based architecture for managing MPLS Traffic Engineering Diffserv aware networks which bases its forwarding on SR-MPLS principles. Architecture has been meant to support also hybrid deployments where SDN equipments coexist with legacy devices guaranteeing same forwarding capabilities. Legacy devices are confined in the core of the network while SDN capabilities have to be supported by the edge devices. In this way, once the controller has calculated the paths meeting the SLA parameters of the flows, programs the network interacting with the edge and setting up the SR paths - over the time the architecture monitors the network and dynamically manages the SR-LSPs in order to ensure that the routing realized by segments does not violate the end-to-end QoS constraints.

Segment Routing and Multicast are combined in \cite{ascalableand}; the authors propose a routing solution for Multicast based on SR and an heuristic with bandwidth guarantees for Multicast tree calculation which takes into account the load of the links, the number of branching points and the state in the network. The objective is to minimize the number of requests being rejected. In particular, the SDN controller computes an explicit Multicast tree using the aforementioned heuristic and then programs the source node of the tree and its branching points: each time a packet reaches a branching point needs to be duplicated and forwarded on different paths and a modification of the segment lists is performed. 
%As regards the routing algorithm, it computes Multicast tree combining several conflicting objectives: link residual bandwidth, node's flow entry and between centrality. The first objective avoids the overloading of the links, the second in somehow takes into account the load on the network nodes. High  ``between centrality'' means that nodes or links have the high opportunity for traffic to go through, this is useful to evaluate possible hot-spots in the network. 
\revnew{Simulation results show that the proposed method outperforms other routing algorithms, however an open source implementation is not available and deeper analysis is not feasible.}

Also \cite{energyefficient} deals with SR based TE. In particular, the authors design an online energy-efficient Traffic Engineering method. They use the SDN controller to selectively switch off and put in sleep mode a subset of links. Then, they dynamically adapt the number of the powered-on links to the traffic load.
%Starting point of this work is to leverage the large over-provisioning adopted in the current providers network. Indeed, according to the authors ``even during peak hours links are rarely used more than 50\%''. 
In this work SR is used to dynamically re-route the traffic. First a least-congested link technique is run to identify the eligible links that can be switched-off. At this point new routes are calculated solving via heuristics the ``Multicommodity Flow Problem''. Finally, SDN controller enforces through SR the new paths or IGP forwarding is leveraged if the route corresponds to the shortest path. At this point the links not necessary are turned off. 
%The authors implement this technique in the OMNET++ simulator and through simulation results they show that as much as 44\% of links can be turned off. The impact on the end-to-end delay is low and there is no packet loss in the analyzed scenarios.
\revnew{Similarly to other works, the problem is solved by identifying first the hop-by-hop paths and then mapping them into SR paths keeping the constraint of the fixed routing over the given hop-by-hop path. The authors of these works provide an interesting analysis implementing the solution in the OMNET++ simulator. However only numerical results are shown and as far as we know an open source implementation is not available.}

The flexibility in path selection achieved by Segment Routing is exploited in \cite{ghuman2017per} to propose a new energy efficiency routing strategy.
The main focus of the work is to switch off a subset of network links, by properly select alternative paths for the traffic currently steered through the target links.
Clearly, the new paths must have enough bandwidth resources to handle the new traffic.
In order to better exploit the available capacity, differently from other energy aware routing strategies that work at the level of traffic flows, in \cite{ghuman2017per} the alternative path selection is performed at per-packet level.
This allows to define a more accurate traffic splitting strategy, that turns in a more efficient use of the available bandwidth, thus increasing the number of switched off links.

The authors in \cite{trafficpmsr} propose an architecture which combines SDN with SR-based TE. An open source implementation of SR-MPLS is provided together with the realization of a SDN control plane which deals with the calculation of the optimal SR paths in the network. The authors start implementing a basic TE heuristic which solves in approximate way the flow assignment problem. The latter allows to minimize the overall network congestion. This first procedure is also used as admission control for the next phase where the admitted paths are mapped onto SR paths using an heuristic of assignment (which has been described extensively in \cite{pmsr} - Section \ref{sec:path}). Performance evaluation analyzes the distribution of path lengths comparing TE paths with the shortest paths and the distribution of the segment list lengths showing that most of the paths can be implemented using 1 or 2 SIDs. All developed code is open source and available at \cite{pmsrcode}

A theoretical analysis of the computational complexity of the Traffic Engineering problems in Segment Routing enabled networks is provided in \cite{ontraffic}.
Two different TE problems are considered: i) the throughput maximization, and the ii) maximum link load minimization.
%While the first TE problem is typical of the Data Center networks, where elastic flows are allowed, the latter better fits in the WAN scenario, where operators aim at reducing the congestion.
As first the General Segment Routing paradigm is considered.
In such a scenario, segments are not constrained to follow shortest paths, but can represents any (possible) complex path.
The resolution of both the aforementioned TE problems results to be NP hard.
This finding provide a theoretical foundation to the reason why, in Segment Routing, shortest paths are considered for each segment.
Then, the complexity of the TE problems is studied for the case of Segment Routing with shortest path.
An interesting outcome of this analysis is that, when the number of segments to be used for each segment list is fixed, then the problem of minimizing the maximum link utilization can be solved in weakly polynomial time.
Despite this, when the length of the segment lists is only upper bounded (not fixed), then the investigated TE problems fall again in the NP hard class.
%For this reason, in \cite{ontraffic} a node centrality based heuristic is proposed, in order to limit the number of nodes to be considered as middle-points, and consequently limit the set of segments to consider (only the ones defined among the selected middle-points).
%In this way, it is possible to reduce the complexity of the TE problems, while keeping a high level of performance. 

In \cite{optimizedte}, the authors deal with SR-based TE designing solutions for the optimal allocation of traffic demands using an ECMP-aware approach. The authors proposes two optimal solutions for online and offline optimization using a 2-segment allocation, \revnew{i.e. limiting the length of Segment Lists to two SIDs}. The latter consists in the computation for each flow the optimal segment list of two segments with the objective of minimizing the overall network congestion. 
%In case of the offline optimization, the traffic matrix is not known in advance but the traffic is forwarded in a such way to even distribute the traffic, considering a wide range of traffic matrices. As regards the online case, the work adopts a competitive approach and assumes that connection requests arrive into the system one at a time and the segments are picked in order to keep the load balanced across the network. 
Key idea of this work is to minimize the worst-case link utilization by considering ECMP forwarding in the offline case. While in the online case, the traffic split values are properly computed also to minimize rejections of requests. Performance evaluation shows that the n-segment routing problem (``Multicommodity Flow Problem'')\revnew{, i.e. with no constraints on the Segment Lists length}, is just slightly better than 2-segment routing problem but the computation complexity is higher due to more degrees of freedom. 
%As regards the offline optimization, it allows to halve the utilization of the bandwidth compared to the shortest path routing. Instead, the online optimization allows to reduce the rejection of a new request for about 30\%

\cite{roomi2018semi} proposes an extension of the models presented in \cite{optimizedte}. In particular, the authors propose the 3-segments forwarding demonstrating that the one defined in \cite{optimizedte}, using two segments, is not sufficient to determine the optimal paths and leads to bandwidth wasting. %Moreover, they introduce a semi-oblivious algorithm which does not need to know the traffic matrix in advance but just the lower and the upper bounds for each flow. The Performance Ratio (PR) defined as relative Maximum Link Utilization is used as evaluation metric for comparison with other TE methods. The proposed model is able to obtain a PR close to $1.0$ which is the optimal value while others solutions are able to reach values close to $0.6$. In other experiments the robustness of the model is evaluated against the fluctuations of the lower and upper bounds and the percentage of the unbounded flows. In the worst conditions, the proposed model is able to obtain a $PR\approx0.6$ which results to be similar to the values obtained by other solutions.

DEFO (Declarative and Expressive Forwarding Optimizer) is a two layer architecture, described in \cite{defo1}, which is realized on top of a physical communication network, aiming at providing a flexible and highly programmable network infrastructure.
At the bottom of the architecture there is a connectivity layer, which is in charge of providing default paths between the network routers.
In DEFO, the connectivity layer is represented by an Interior Gateway Protocol (IGP).
By means of an optimization layer, the routing paths of a subset of traffic demands is deviated by the default behaviour, provided by the connectivity layer, and is steered through a set of optimized paths.
DEFO exploits the flexibility of Segment Routing to implement the optimization layer and configure optimized paths on top of underlying routing paths.
The Service Provider can program the network leveraging a high level interface that allows to define specific network goals through the use of a Domain Specific Language (DSL).
\revnew{DEFO makes possible for a network operator to define multiple cost functions to be optimized. In the basic case, referred to as “Classic Traffic Engineering”, maximum link utilization is minimized;  in the “Tactical Traffic Engineering” case, the objective function is a combination of the  maximum link utilization and the number of modified paths.}
Once the goal has been specified, DEFO starts the computation of optimized paths, by running an algorithm that exploits the concepts of Middle-point Routing (MR) and Constraint Programming (CP).
%In the MR model, a path between a source node s and a sink node t is represented by a sequence of acyclic graphs, called partial forwarding graphs (PFG).
%Two consecutive PFGs, share a common node, which is called middle-point.
%Specifically, a middle-point is a sink for a PFG and a source for the consecutive one.
%In DEFO architecture, a PFG represents a forwarding path found by the underlying connectivity layer.   
%A Local search algorithm is used by DEFO as heuristic to compute optimized paths: CP is used to find the best solution in a small region of the solution space, while a randomized approach is used to leave from local optimum.
%The final outcome is represented by a sequence of middle-points for each demand.

\cite{gay2017expect} faces the problem of fast reacting to sudden traffic changes. In fact, these unexpected events, which occurs at low time scale, can create temporary congestion on links, thus degradating the network performance.
Classical solutions to face this issue are based on MILP models or Constraint Programming, see \cite{optimizedte} and \cite{defo1}. Unfortunately, these approaches suffer to high computation time, since they work in a time scale of seconds or minutes, providing TE routing strategies that on average allow to reduce the network congestion, but that might incur in link overloading due to sudden traffic spikes.
For this reason, in \cite{gay2017expect} the authors present an algorithm which aims at mitigating link congestion under hard time constraint.
The proposed solution exploits SR to fast and flexibly re-route a subset of flows, so that to decrease the maximum link utilization. Time constraint is taken into account under two different perspectives: i) it is directly consider as hard constraint during the algorithm execution, i.e, it is a termination condition, and ii) the selected routing strategy has to be as close as possible to the current one, in order to minimize the number of reconfiguration needed to make it working.
These two requirements are simultaneously satisfied by the proposition of a Local Search (LS) based heuristic, which takes as input an initial solution and iteratively goes from that solution to another one, by applying local changes called moves, until a stop criterion is met (e.g. the solution is good enough, or a time limit). 
%Specifically, at each iteration, the proposed algorithm randomly selects a link and a traffic demand passing on it, and tries to detoure it by modifying its segment list. The set of paths obtained by the modification of the current segment list represents the neighborhood. A segment list can be modified by performing one of the following operation: i) \emph{insert}, which add a new sid in the segment list, ii) \emph{remove}, which remove a sid from the segment list, iii) \emph{replace}, which substitute a sid with a different one, and iv) \emph{reset}, which forces the demand to be routed over the shortest path. Among the set of candidates, the next neighbor is decided according to a hill climbing criterion, i.e., the one that better improve the value of the objective function. Finally, in order to escape from local optimal points, a meta-heuristic component is added. 
Results show that the proposed algorithm overcomes MILP or Constraint Programming based heuristic, allowing for a significant reduction of network congestion with execution times lower than 1 second.

The Segment Routing Path variable is introduced in \cite{defo2} with the aim of reducing the memory space and the computation time to formulate and solve TE problems in SR networks.
In fact, while the memory space needed to instantiate classical TE problem formulations based on links, paths or nodes variables do not scale well with the size of the considered network and with the number of demands to be routed, SR path variables promise to increase efficiency in the problem resolution.
SR Path variables are based on the concept of Forwarding Graph (FG).
An FG is a Direct Acyclic Graph (DAG) that originates from a node s and terminates on a sink node t.
The path followed by a demand in the network is encoded as a sequence of FGs, and this sequence is stored into an SR path variable.
Array-based sparse-sets are used to implement SR path variables.
%Specifically, for each demand two arrays, named nodes and map, and two integers V and R are defined.
%The map array maps each node to its position in nodes.
%The first V elements of the node array represent the visited FGs, while the ones stored in the positions between V and R are the candidates ones, i.e., the FGs that can be potentially used to extend the sequence of considered FGs.
%In order to determine whether an FG is a candidate, specific functions are applied.
%These functions implements constraints.
%Some examples are the channeling constraints, that filter FGs that, in case used to expand the SR path, causes a congestion on a link, or the length constraint that forces an SR path to be composed of a maximum number of FGs.
A Large Neighborhood Search approach is used to compute optimized paths for the demands.
The idea is to iterative improve the best-so-far solution trying to reassign the value of a subset of SR path variables, related to demands that are critical (e.g. all the ones that are currently routed over the most loaded link).

\cite{incrementaldeploy} investigates the problem of migrating an IP network in a full SR enabled one.
The idea is that, the process of upgrade the system of IP routers in order to enable SR capabilities is done incrementally, so that to reduce the chance of introducing possible misconfigurations or unavailability of the service.
To do that, the Segment Routing Domain (SRD) is defined as the subset of SR capable nodes.
Depending on the fact that the SRD is a connected set or not, two different models are proposed: Single-SRD or Multiple-SRD.
Two main advantages of S-SRD model are that it limits the number of flow states to be maintained at the edges of the SRD, and the average length of the segment list is restrained.
As a main drawback there is a potential decrease in the flexibility in the definition of network paths.
On the contrary, M-SRD allows to define more complex paths at the cost of having a higher number of flow states and a higher average segment list length.
The Segment Routing Domain Design problem is formulated as an ILP, where the main goal is to maximize the Traffic Engineering opportunities, i.e., the identification of the subset of nodes, of a given size, to be upgraded with SR capabilities, so that to have the highest possible flexibility in balancing the links load in the network.
The proposed formulation is able to capture both S-SRD and M-SRD models.
%Due to the high computational complexity, a study of the parameters that seem to drive the design of an efficient (in terms of TE opportunities) SRD, is presented in \cite{incrementaldeploy}.
%Among the several analyzed parameters, the one that seems to provide better indication is the overall traffic routed through a node, i.e., the nodes that generally are crossed by the largest amount of traffic are the ones that should be upgraded first. 
\revnew{The work shares several design principles with other works reported in this survey, for example it considers incremental deployments of SR and deal with path aware encoding of the segments list in order to guarantee that SR path will follow exactly the hop by hop path decided by TE heuristics. With respect to other works, the authors propose also a loose forwarding solution where the packets belonging to the same flow can cross the network using different paths.}

\cite{moreno2017traffic} proposes ILP models and heuristics for TE applications in SR-based networks. Three ILP models are proposed and they are only used as benchmark for the heuristics due to their high computational complexity. The first is able to leverage ECMP forwarding, the second one computes single routes and implements an hop-by-hop forwarding. Finally the third one is able to leverage the full capability of Segment Routing. An heuristic has been implemented as some instances of the ILP models require too much time to be solved. The heuristic computes an unique route for each flow and tries to keep the total and the maximum network utilization as low as possible. Moreover, it is able to guarantee that the maximum value of the segment list depth is not exceed. 
%The weights of the routes are calculated using three different expressions, which defines three different variants of the heuristic: i) selects the route whose sum of its links utilization multiplied by the number of labels is minimum; ii) uses the minimum utilization to select a route; iii) selects routes trying to keep the maximum link utilization as minimum as possible. A performance evaluation has been performed comparing the ILP approaches and the ILP models with the implemented heuristics. In general the ILP model leveraging the full-fledged SR architecture can achieve minimum maximum links utilization at the expenses of the length of the routes and average utilization. Comparing heuristics with the ILP models has not been always feasible. Heuristics have negligible execution times also when running on inexpensive hardware. However they cannot achieve the same utilization levels of the ILP models leading to higher values.

\cite{pereira2017optimizing} proposes a TE solution for paths computation that, leveraging at most three labels, is able to optimize link resources and avoid congestion in the network. Firstly, the SDN controller address the problem of properly compute the weights of the IGP Link State protocol using Evolutionary algorithms. Then, the traffic distribution is computed through the Distributed Exponentially-weighted Flow SpliTting (DEFT) or the Penalizing Exponential Flow-spliTting (PEFT) which assign the flows to a next-hop with a probability that decreases exponentially with the extra length of the path (with the respect of the shortest path). SR is used to achieve detours and implement the traffic splitting. Performance evaluation shows that the TE solution delivers a lower congestion with the respect of OSPF/ECMP with optimized configurations and is able to use all available links. %Finally, with a second experiment the authors show that through a proper parameters tweaking the algorithm is robust also to traffic demand variations.

The flexibility of SR in path selection, together with the higher throughput provided by the Multi Path TCP (MPTCP), are exploited in \cite{barakabitze2018novel} in order to optimize the throughput for large flows and cope with the explosive growth of multimedia traffic, in 5G networks.
The propose architecture uses a centralized control plane, with a central controller in charge of managing the Quality of Experience of each MCTCP connection.
In particular, the central controller finds multiple paths for each connection, checks the bandwidth requirements and install specific flow rules at the ingress nodes of the considered 5G network.
When a new MPTCP connection is established, the controller must find a path for each of the subflows belonging to this connection.
For each subflow, it first check the flow path and resource database, in order to check whether there is already a pre-computed path that has enough bandwidth to support the new subflow.
In case this check fails, then the controller calculates a new path, encodes it into a segment list and install a new flow entry in the ingress switch.
The algorithm used to compute the new paths, named QoE-Centric Multipath Routing Algorithm (QoMRA), tries to find multiple disjoint paths by while considering QoE requirements.

\cite{pang2017sdn} proposes to use Multi Path TCP (MPTCP) \revdel{and} \revnew{in tandem with} SR\revnew{-MPLS} to maximize the throughput of the traffic flows in a Data Center network. M\revnew{P}TCP allows to split a single connection over several paths, increasing then the \revnew{total throughput}\revdel{bandwidth utilization}. \revnew{SDN-based MPTCP solutions are considered by the authors to achieve fine-grain control over the TCP connections.}\revdel{Clearly} \revnew{However}, \revdel{it also} \revnew{this} drastically increases the overall number of \revnew{the} traffic flows \revnew{that need to be stored in the devices}, by making scalability issue to arise. SR is used to reduce the number of flow rules needed to steer the single TCP connections over disjoint paths\revdel{.} \revnew{and to save precious space in the Ternary Content Addressable Memory (TCAM) of the devices.} \revnew{The architecture envisages a reactive approach for the flows allocation: each time a new subflow is ``generated'' by MPTCP, a Packet-In is sent to the SDN controller which allocates a new disjoint path whenever is possible and then installs the necessary flowrules to support this subflow in the edge devices. SR allows to reduce the state in the core device, unfortunately from the paper is not clear how the authors can avoid the explosion of the state at the edge of the network due to the matching conditions at the transport layer.}

In \cite{dugeon2017demonstration}, ELEANOR, a northbound application for the OpenDayLight (ODL) Software Defined Network (SDN) controller is presented.
ELEANOR considers MPLS-SR data plane, where a Maximum Stack Depth (MSD) constraint, i.e., an upper bound on the number of sids that can be stacked in a segment list, has to be considered.
The main components of ELEANOR are: i) a path computation module, and ii) a label stack optimization module.
When a new request arrives at the controller, it first finds a suitable path in order to meet specific QoS requirements (bandwidth, delay, etc.), then the appropriate SL is produced.

In \cite{hou2019optimization}, the authors proposes two routing algorithms based on SR for realizing TE applications in SDN networks. These algorithms  search for an appropriate selection of the links weights for optimizing paths costs and balancing load across the links. This is obtained through the multiple objective particle swarm optimization (MOPSO) algorithm. Two objective functions are used to measure path cost and load balancing, respectively.
According to the authors, their algorithms not only reduce the cost of the paths, better balance the network load, and decrease the maximum link utilization rate but also can improve the satisfaction ratio with respect of shortest path first (SPF), shortest widest path (SWP), widest shortest path (WSP), minimum interference routing algorithm (MIRA), and the Lee algorithm.

%In \cite{hou2019optimization}, the authors proposes two routing algorithms based on SR for realizing TE applications in SDN networks. The algorithms are composed of several stages. First step is to find an appropriate selection of the links weights for optimizing paths costs and balancing load across the links. This is obtained through the multiple objective particle swarm optimization (MOPSO) algorithm. Two objective functions are used to measure path cost and load balancing, respectively. Then, the algorithm chooses the first k shortest paths from an optimized weighted matrix between the source node and the destination node. It chooses the first k shortest paths to get a shorter segment list. Finally, the authors apply a model which takes as input the preferences of the application and the selected k paths. This model calculates the path having the best fit according to the user preferences. The algorithm described so far is what the authors call algorithm 1. The second one, mentioned in the paper, applies an improved MOPSO algorithm for the optimization of link weight which allows to improve ``the search performance in terms of convergent speed and precision''. According to the authors, their algorithms not only reduce the consumption of the paths, better balance the network load, and decrease the maximum link utilization rate but also can improve the satisfaction ratio with respect of shortest path first (SPF), shortest widest path (SWP), widest shortest path (WSP), minimum interference routing algorithm (MIRA), and the Lee algorithm.

\revnew{\cite{settawatcharawanit2018segment} proposes the Bounded Stretch constraint to boost the resolution of SR-TE problem. The Bounded Stretch is used to shrink the set of intermediate node candidates, which are selected during the building of the SL. This allows to reduce the space of the solutions. The high level idea of the Bounded Stretch is that when an intermediate node is too far away from a source node $i$ to a destination node $j$ then this node should not be considered as a candidate. The selection is achieved comparing the length of the intermediate shortest paths with the length of the end-to-end paths scaled by a given constant. The authors demonstrate through experiments that the constraint helps in reducing the computation time at cost of having a slight higher utilization over the links.}

\revnew{In \cite{trimponias2019node}, the node constrained TE problem is defined and analyzed, and SR is claimed to be an enabling technology for such routing strategies.
This problem consists in the optimization of one of these two objectives: maximize the network throughput, or minimize the maximum congestion.
Different routing strategies are considered. 
In the most general case, end to end paths are constrained to go through a set of middle-points, leaving the freedom to choose whatever path between two middle-points.
This problem is formulated and proven to be NP-hard.
Next, the feasibility region is limited by forcing the path between two middle-points to be the shortest one.
The derived problem formulation turns out to be solved in weakly polynomial time.
Anyway, since the solutions of the previous problem can contain routing loops (the same link is crossed two times), the authors of \cite{trimponias2019node} also consider a variant where the solution is constrained to select only acyclic end to end paths.
This last variant of the node constrained TE problem is shown to be NP-hard.
A further contribution of \cite{trimponias2019node} is the proposition of the concept of \emph{flow centrality} as a design parameter to select the most suitable middle-points.
The flow centrality is expressed as the maximum percentage of traffic that can go through a node.
This concept is further enhanced by defining the \emph{group flow centrality}, which is a generalization of the flow centrality over a set of N middle-points.}

\revnew{The work in \cite{zhang2019bandwidth} proposes a traffic engineering solution (path computation and bandwidth allocation) for a hybrid IP/SR network able to maximize a utility function reflecting user satisfaction. User satisfaction is computed as a logarithmic function of the bandwidth assigned to flows. Routing paths are constrained to be the shortest ones in the IP domain, while SR routers can choose among a set of allowable paths in the SR domain. After defining the optimization problem, a two-step iterative algorithm is proposed: at each step of the iteration, link weights inside the SR domain are updated. Two main assumptions are made: i) each flow can be forwarded on a single path, and i) a packet cannot cross the SR domain more than one time.}

\revnew{Independently from the aim of the optimization and of the considered constraints, the main goal of a TE strategy is to find a routing configuration for a given set of input demands. Here we outline some of the differences between the SR related research works classified in the category \emph{Traffic Engineering}. Specifically, we point out five different criteria to compare them: i) the type of approach (optimization based, heuristic based, both), ii) the demand granularity level (Origin-Destination or Ingress-Egress), iii) the path computation strategy, iv) how the TE routing is translated into a set of SLs, and v) the traffic split policy (single SL or multiple SLs).}

\revnew{Most of the works on \emph{Traffic Engineering} with SR propose a heuristic algorithm to determine a set of paths to satisfy a given objective. Only in \cite{ontraffic}, \cite{optimizedte}, \cite{incrementaldeploy}, \cite{moreno2017traffic}, \cite{settawatcharawanit2018segment} and \cite{zhang2019bandwidth} it is also presented a problem formulation.
Another interesting difference between the research works on \emph{Traffic Engineering} is the model considered to describe the traffic demands. In fact, while \cite{trafficpmsr}, \cite{trimponias2019node}, \cite{defo1}, \cite{gay2017expect}, \cite{barakabitze2018novel}, \cite{pang2017sdn}, \cite{dugeon2017demonstration}, and \cite{settawatcharawanit2018segment} consider an Origin-Destination (OD) model, where multiple demands can enter and leave the network from the same pair of Ingress-Egress (IE) nodes, all the others assume an IE model (there is a single demand between each pair of IE node that is representative of the aggregation of many OD flows).
This affects both the flexibility of the solution, allowing for a thinner optimization, than the complexity of the algorithms, since they have to deal with a larger number of variables.}

\revnew{Different strategies are used to create the end to end paths. Some of them are based on the definition of parameters able to catch the current network status. The paths are then selected according to a Least Cost rule.
As an example, in \cite{anefficient} are defined the link ``criticality'' and the link congestion index, \cite{trafficpmsr} defines the concept of network crossing time, \cite{trimponias2019node} reduces the feasible path space by imposing that only nodes with high centrality can be used as middle points. In \cite{zhang2019bandwidth} single path routing is considered and the objective function of the optimization problem is the user satisfaction, calculated as a logarithmic function of the bandwidth allocated to the user flows. Furthermore, also in \cite{barakabitze2018novel} the path search strategy is based on the link criticality, while \cite{pang2017sdn} exploits the concept of delay index.
The remaining works use more sophisticated techniques, such as constraint programming (\cite{defo1,defo2}), ILP based search (\cite{energyefficient,ghuman2017per,optimizedte,roomi2018semi,incrementaldeploy}, local search heuristic (\cite{gay2017expect}), and constrained Shortest Path First algorithms (\cite{dugeon2017demonstration}).}

\revnew{Another interesting difference of the path selection strategies adopted by papers falling in the \emph{Traffic Engineering} category is related to the way they generate the SLs associated to the determined path.
Specifically, two different approaches are generally used: i) the path is found and then encoded into a SL (\cite{energyefficient,incrementaldeploy,moreno2017traffic,barakabitze2018novel,pang2017sdn,dugeon2017demonstration}, or ii) the path is directly constructed as a SL (\cite{optimizedte,roomi2018semi,defo1,defo2,gay2017expect,pereira2017optimizing,settawatcharawanit2018segment,trimponias2019node}).}

\revnew{Last comparison we propose is related to the possibility to split the traffic demands over multiple SLs.
This option, which is allowed by properly configuring the SR policies, is explicitly used in the algorithms described in \cite{optimizedte,roomi2018semi,incrementaldeploy,pereira2018segment,barakabitze2018novel,pang2017sdn}.
Clearly, having the possibility to split the same flow over multiple SLs increases the flexibility of the routing strategy, at the cost of increasing the information to be stored in the head end nodes, where SR policies are installed.}

\subsection{Failure Recovery}
\label{sec:fail}

\FailurePapers research works dealing with SR for Failure Recovery and Network Resiliency have been published in the last years. 
The proposed solution can be classified considering the type of failure they are able to recover from:, i.e.link or node failures.
Table \ref{tab:failure-recovery} shows the classification of the covered papers.

\begin{table}
\centering
\caption{\\Classification of the references related to Failure Recovery.}
\label{tab:failure-recovery}
\begin{tabular}{|c|c|}
\hline
\textbf{Node failure} & \cite{trafficduplication},\cite{aubry2018robustly},\cite{optimizingrestoration},\cite{segmentfor},\cite{srdynamicrestoration},\cite{reliablesr}                                             \\ \hline
\textbf{Link failure} & \begin{tabular}[c]{@{}c@{}}\cite{timfa},\cite{trafficduplication},\cite{aubry2018robustly},\cite{segmentfor},\cite{srdynamicrestoration},\cite{reliablesr} \\ \cite{xhonneux2018flexible},\cite{foerster2018local}\end{tabular} \\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as Failure Recovery related works.

\cite{timfa} deals with resilient SR forwarding. In particular, the authors focus on static fast failover solutions for Segment Routing which do not require the interaction with control plane, the algorithm, the so called \revdel{TI-MFA} \revnew{Topology Independent Multi-Failure Alternate (TI-MFA), which is an improvement of the Topology Independent Loop Free Alternate (TI-LFA), described in \cite{id-segment-routing-ti-lfa} and elaborated in Section \ref{sec:key_standard}. TI-MFA} has interesting performance guarantees and it is also resilient to multiple failures while traditional SR fast failover based on TI-LFA can work only with a limited number of failures. Firstly, the authors demonstrate that TI-LFA loops indefinitely also for two link failures. Then, a robust but inefficient solutions is shortly presented which pre-compute routing rules considering destination, incident failures and incoming port of the packets. Even if this solution can provide better resiliency guarantees, it introduces some inefficiencies (in terms of path lengths) even if only one link failure occurs. Finally, the authors present their solution which basically proposes to store the already hit failures in the packet header and, each time a new failure is faced in the network, the segment list is re-computed using the pre-computed local table entries and the state stored in the packets. %Formal correctness is demonstrated by the authors. Moreover, simulation results show: lower failures rate; maximum stack size at most equals to 3 and lower average path lengths.

Traffic duplication through disjoint paths is explored in \cite{trafficduplication}. In particular, the authors leverage SRv6 to realize a traffic duplication service which can guarantee an 1+1 protection scheme through the use of disjoint paths. Main difference with other protection mechanisms is that with 1+1 protection both channels are active and data is sent over both paths. The authors use mirroring behavior in the Linux kernel to realize the traffic duplication. Work builds upon the results of \cite{srv61}, in particular it leverages the Linux implementation of SRv6. Then, the authors propose an algorithm that is able to compute disjoint paths with least latency and that can be implemented with a number $k$ of segments (they set an upper bound limit on their number and use only node segments). %Performance evaluation of the traffic duplication method shows its benefits for low latency applications. Moreover, the authors analyze the properties of the k-segments algorithm: results show that it is able to find disjoint paths with least latency and comparable delays.


\cite{aubry2018robustly} extends \cite{trafficduplication} with the introduction of the robustly disjoint paths. The authors built, extending routing theory and leveraging configuration synthesis, an automated compiler which is proactive, fast and self-healing (no external intervention are required): it computes pairs of disjoint paths for given sources and destination routers which are robust in the way that they remain disjoint even upon a set of failures. This is achieved without requiring any intervention thanks to SR technology. Indeed, SR allows to write sequences of segments which maps to different disjoint paths even when there are topological changes. Finally, leveraging the results of \cite{trafficduplication}, Aubry et al. added to the compiler the capability of limiting the number of segments (i.e. path encoding problem) and computing paths that do not degrade data-plane performance (finding low latency SR paths - addressing also TE aspects). %The authors extensively tested their approach with simulation on 3 large ISPs networks, on the Rocketfuel topologies and on the largest topologies in the Internet Topology Zoo database. Moreover, they have analyzed and compared main alternatives (SPF, MPLS/RSVP-TE and OpenFlow) with their approach in terms of: i) path disjointness; ii) network state; iii) expressiveness; and iv) failure reaction}

In \cite{optimizingrestoration}, Hao et al. propose a linear programming model to optimize the restoration in SR based networks. Key idea of the optimized restoration is to share properly the remaining bandwidth when several failures happen, and this is addressed through an optimal configuration of the initial segments, knowing in advance the traffic matrix and the network topology. In particular, the authors develop an efficient primal-dual algorithm which can handle single link failures and multiple logical link failures at the same time (including node failures). Moreover, with a simple randomized rounding scheme they can take into account also ECMP forwarding in the network. 
%Experiments show that in terms of throughput the algorithms are just slightly worse than the maximum concurrent flow algorithm while the shortest path calculation performs worse in all the benchmarked network topologies and in some case delivers an halved throughput compared to the designed algorithms.

A logically centralized implementation of the SR control plane (SDN based) is leveraged in \cite{segmentfor}, \cite{srdynamicrestoration} and \cite{reliablesr}\revnew{. They} describe a method to dynamically recover the network from link or node failures. 
%The central controller is involved only initially to compute the segment list and program properly the network through an algorithm which is able to minimize the list depth. Instead, the controller is not involved when a failure occurs since the traffic is locally recovered. 
The failover mechanism envisages a failover table for each interface of the node and when a port goes down automatically the related secondary table is used to implement a loop-free backup path from the point of failure to the destination node. Firstly, the node pops all the labels in the segment list except the last label (which represents the final destination), and then the packet processing is passed to the proper failover table. The authors provide an implementation based on the \revdel{OF} \revnew{OpenFlow (OF)} protocol leveraging the \revnew{OF} Group tables feature for monitoring and backup actions \revnew{(\cite{grouptutorial} explains how to use OF Fast-Failover Group)}. \revnew{In \cite{reliablesr} and in \cite{srdynamicrestoration}, the SR path encoding algorithm can lead to longer segment lists than the one generated by the algorithm proposed in \cite{segmentfor}. In general a low number of labels is necessary to implement most of the backup paths. \cite{reliablesr} and \cite{srdynamicrestoration} implements a simple detour from the node detecting the failure towards the next-hop or the next-next-hop.}% Performance evaluation shows the improvements of the algorithms used in \cite{segmentfor} in terms of segment list depth and the distribution of the segment list depths for the backup paths.% Average value of the recovery time is in the order of tens of milliseconds.

The same authors of \cite{xhonneux2018leveraging} propose an open source implementation of SRv6 TI-LFA \revnew{in \cite{xhonneux2018flexible}} using \revnew{the extensible Berkeley Packet Filter framework (a thorough article explaining eBPF concepts in the Linux kernel is reported here \cite{lwn-ebpf})}\revdel{eBPF}\revdel{in \cite{xhonneux2018flexible}}. The fast rerouting solution is implemented as a custom BPF program compiled on the fly and attached to a route. In particular a program is loaded into the kernel for each link to be protected. The repair list associated to the route is computed by the control plane and then hard-coded in the eBPF program which is subsequently compiled and installed in the kernel. The solution has been complemented with a robust failure detection architecture which implements the \revnew{Bidirectional Forwarding Detection (BFD) \cite{rfc5880}}\revdel{BFD's} echo mode using SRv6. In particular, the architecture envisages for each link a master node periodically sending probes which can activate the fast rerouting mechanism described so far. 
The probes are sent with a special segment list which allows redirecting the traffic to a special BPF program (BPF slave) on the remote peer and looping back the probes to the master. The BPF slave, running in the remote peer, handles the probes packets and can activate the SRv6 TI-LFA mechanism for its side of the link. The master uses SRv6 type-length-value to insert sequence numbers and timestamps which allow also the remote peer to detect failures. The evaluation in the paper considers the number of false positives due to an overloaded CPU, the BPF implementation of the peer nodes allows reducing the false positives almost to zero even when the failure detection is less than $10ms$. Instead, the master node is still largely affected by the overloading of the CPU since it uses an user space process for sending the probes.

%Even though one of the use cases available for SR is the Topology Independent Loop Free Alternate (TI-LFA), it does not address the case in which more links fail at the same time.
%In this particular but not infrequent case (eg. many logical links mapped on the same physical link), possible loops might happen, causing network disconnection.
\cite{foerster2018local} study the problem of defining a backup path scheme that is robust to the presence of multiple link failures. 
Specifically, the main contributions are: i) introduction of a polynomial-time fast rerouting algorithm which allows to define a backup path scheme for resilience under $k$ simultaneous link failures in particular case of a hyper cube topology, and ii) the formalization, by means of an ILP formulation, of the problem of defining a backup path scheme that maximizes the number of allowed simultaneous link failures in general graphs.

\revnew{Let us provide a comparison among the works classified in the \emph{Failure Recovery} category.}

\revnew{\cite{xhonneux2018flexible} proposes an implementation of the TI-LFA mechanism \cite{id-segment-routing-ti-lfa} in a linux based SRv6 node. \cite{timfa} extends TI-LFA mechanism adding the capability of handling multiple failures.}

\revnew{Among the solutions based on SR to recover from network failures, there are only two works (\cite{timfa,foerster2018local}) which aim at dealing with multiple failures. While the first is more focused on implementation aspects, the latter is more theoretical and focused on the definition of algorithms to find loop-free re-routing strategies. All the other recovery mechanisms are not explicitly declared able to deal with such a failure scenario.}

\revnew{Another interesting difference between the failure recovery solutions is the method they are based on. Specifically, most of them (\cite{timfa,segmentfor,srdynamicrestoration,reliablesr,xhonneux2018flexible,foerster2018local}) are based on a re-routing strategy, i.e., the packets are detoured over a pre-computed alternative path once a link is declared as failed. On the other hand, \cite{trafficduplication,aubry2018robustly} are based on a traffic duplication scheme.
Without going into the details, the main difference between \cite{timfa,foerster2018local} and \cite{segmentfor,srdynamicrestoration,reliablesr, xhonneux2018flexible} is on the number of simultaneous failures they allow to recover from.}

\subsection{Centrally Controlled Architectures}
\label{sec:central_control}

The definition of Centrally Controlled Architectures exploiting the SR architecture has been widely investigated in literature, resulting in \ccaPapers different works.
The solution proposed has been classified on the basis of three different aspects, as reported in Table \ref{tab:central-control}. Considering the SR data plane, a high number of works makes use of the SR-MPLS data plane while only three works are based on SRv6. Moreover, few works do no explicitly consider a specific SR implementation but simply exploit the SR possibility of inserting the flow state in the packet header.
A further aspect used to classify the research papers is the protocol used for the southbound communication between the network devices and the central controller.
The considered protocols are Openflow, PCEP or others.
The last component that differentiates the proposed architectures is the underlay network.
Specifically, the network devices can be IP/MPLS routers or Openflow switches.


\begin{table}
\centering
\caption{\\Classification of the references related to Centrally Controlled Architectures.}
\label{tab:central-control}
\begin{tabular}{|c|l|c|}
\hline
\multirow{3}{*}{\textbf{SR data plane}}                                                   & \textit{SR concept} & \cite{fressancourt2015sdn},\cite{li2017segment},\cite{experimentalmulti},\cite{eramo2019effectiveness} \\ \cline{2-3} 
                                                                                         & \textit{SR-MPLS}    & \begin{tabular}[c]{@{}c@{}}  \cite{firstdemonstration},\cite{sdnandpce},\cite{paolucci2018network},\cite{paolucci2017service}\\ \cite{castoldi2017segment},\cite{springopen},\cite{demonstrationofsr},\cite{evolve} \end{tabular} \\ \cline{2-3} 
                                                                                         & \textit{SRv6}       & \cite{ventre2018sdn},\cite{lebrun2018software},\cite{duchene2018exploring},\cite{barakat2019busoni}                                              \\ \hline
\multirow{3}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Southbound\\ Interface\end{tabular}}} & \textit{Openflow}   & \cite{firstdemonstration},\cite{castoldi2017segment},\cite{springopen},\cite{li2017segment} \\ \cline{2-3} 
                                                                                         & \textit{PCEP}       & \cite{sdnandpce},\cite{paolucci2018network},\cite{paolucci2017service},\cite{demonstrationofsr} \\ \cline{2-3} 
                                                                                         & \textit{Other}      & \cite{ventre2018sdn},\cite{demonstrationofsr},\cite{evolve}                                              \\ \hline
\multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Underlay\\ data plane\end{tabular}}}   & \textit{IP/MPLS}    & \begin{tabular}[c]{@{}c@{}} \cite{sdnandpce},\cite{paolucci2018network},\cite{castoldi2017segment} \\ \cite{springopen},\cite{demonstrationofsr}\end{tabular} \\ \cline{2-3} 
                                                                                         & \textit{IP/SDN}     & \begin{tabular}[c]{@{}c@{}} \cite{ventre2018sdn},\cite{firstdemonstration},\cite{fressancourt2015sdn},\cite{li2017segment},\cite{lebrun2018software}\\ \cite{duchene2018exploring},\cite{barakat2019busoni}\end{tabular}\\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as Centrally Controlled Architectures related works.

\cite{firstdemonstration} implements an SDN based SR-MPLS architecture in a multi-layer packet-optical network. In particular, the authors demonstrate optical bypass upon traffic load variations without requiring GMPLS operations. The RYU SDN controller \cite{ryu} has been extended to control the labels stack configuration at the edge nodes (Open vSwitch based). The SDN controller utilizes OF 1.3 to program the edge devices. Open vSwitch has been modified to increase the maximum MPLS stack depth from 3 to 15 labels. The OF protocol has been modified as well to push all the required labels as a single flow entry and with a single action. Commercial \revnew{Reconfigurable Optical Add-Drop Multiplexer (ROADM) devices}\revdel{ROADMs} have bee\revnew{n} used to provide an optical bypass between nodes and provide alternative paths during path computation. 
%Finally, the authors assess the scalability performance of the SR-based solutions. Two experiments are presented, in the first one the authors showcase the capability of their policy routing algorithm which performs a constrained shortest path calculation based on the available bandwidth and according to this re-route traffic in the network. Devices can easily steer the traffic leveraging SR-MPLS. While, 
\revnew{In the performance evaluation the authors asses through emulation the influence of the 15-labels deep stack evaluating the flows setup time and the packet forwarding in the devices. The latter is not influenced at all while the setup time is almost triple.}

Later in \cite{sdnandpce}, SR has been implemented in a multi-layer network using a PCE architecture instead of SDN/OF. In this scenario nodes consist of commercially available IP/MPLS routers and the SR Controller is an extended version of PCE stateful control plane. Extensions to the PCE protocol allow a centralized PCE to control the label stacking configuration. PCC (PC client - devices) uses the SR-PCE-CAPABILITY type-length-value for specifying the capability of handling SR-enabled Label Switched Paths and the capability to perform SR computation. The Explicit Routing Object (ERO) carried out in the Path Computation Reply message contains the list of computed SIDs and/or the Node or Adjacency Identifier depending on the SID type. On the device the agent collects the information derived from IGP protocol and configures the related shortest path entries and the SID labels. When a new PC replay message is received, the label stack is properly configured. Also this SR implementation using PCE is able to perform dynamic packet rerouting (with optical bypass capabilities), by enforcing different segment-lists at source node, without any signalling protocol and with no packet loss.

In \cite{paolucci2018network} Segment Routing is proposed as enabling technology to realize Network Service Chaining (NSC) in a metro-core network scenario, where service chain requests are represented by the so called micro flows, i.e., a huge number of low or medium bit-rate flows.
In this scenario, classical solutions based on MPLS or pure SDN fails due to scalability issues.
%Specifically, the cost of the signaling traffic needed to set up a Label Switching Path (LSP) for each micro flow would be excessive in case of MPLS based solutions, requiring the adoption of an LSP for an aggregation of micro flows.
%This would affect the flexibility of the architecture in terms of ability of optimize the use of the network resources.
%Also pure SDN based solutions suffer of scalability issues.
%In fact, the configuration of the path to be followed by a single micro flow requires the installation of a flow rule in the flow table of each SDN switch belonging to that path.
On the contrary, SR moves the flow state into the packet header, reducing the configuration costs (and time) to the installation of the encapsulation rule at the ingress point of the network (the one used to add the segment list to each packet of the considered flow).
Based on this consideration, \cite{paolucci2018network} describes an SR Path Computation Element (SR-PCE), which is in charge of orchestrating connection setup/release/modification, and is made by two main modules: i) the flow computation element, having the goal of find a path with available resources to serve a micro flow and ii) flow steering API that is responsible of installing the SR encapsulation rule in the ingress node.
An experiment evaluation of the proposed architecture is proposed in \cite{paolucci2017service}.

\cite{castoldi2017segment} proposes a SR-based Software Defined Network (SDN) architecture which is able to perform load balancing among ECMP and non-ECMP routes in multi-layer networks including an IP/MPLS layer over an optical network layer. In particular, two solutions are described: i) Centralized-SR; ii) Preconfigured-SR. The former leverages a SDN controller to steer traffic over alternative paths upon network failures. Instead, the second solution uses OpenFlow load-balance groups to actively forward the traffic on several routes. With the second solution the data plane layer can autonomously react to a network impairment removing the failed output port while the first solution always requires the intervention of the SDN controller but results to be more generic with regards of the second one. Both solutions push the SID of the destination node and leverage the available ECMP paths. The recovery property of the architecture has been validated simulating network failures. According to the authors, some packet losses have been recorded and the recovery time was around $170ms$.

The SPRING-OPEN project \cite{springopen} is an ONOS \cite{onos} use case, which provides an open source SDN-based implementation of SR. Its architecture is based on a logically centralized control plane, built on top of ONOS, and it drastically eliminates the IP/MPLS Control Plane from the network. Part of this work converged later in the Trellis project \cite{trellis}, an SDN based leaf-spine fabric, built using bare-metal hardware, open-source software from the OCP \cite{ocp} and ONOS projects, and \revnew{OpenFlow-Data Plane Abstraction} (OF-DPA)  \cite{ofdpa}, an open-API from Broadcom \cite{brcm} to program merchant-silicon ASICs. The leaf-spine fabric is based on SR-MPLS principles, however it does not implement the full fledged SR architecture and it just uses global significant Node-SIDs. These MPLS labels are statically configured in the SDN control plane and are used to globally identify the ToR switches of the fabric and routes the traffic towards them using a single MPLS label.

In order to provide resiliency against link and node failures for Cloud Service Provides (CSPs), an overlay infrastructure realized by means of Segment Routing and Software Defined Networking control plane is proposed in \cite{fressancourt2015sdn}.
The main idea of the proposed architecture is to substitute the dedicated physical infrastructure that interconnects Data Centers of a CSP, with an overlay network realized on top of an underlay infrastructure, represented by the interconnection of many Internet Service Provider (ISP) networks.
The prerequisite is the availability of multi-homed connections for each Data Center of the CSP.
Then, the logical component of the proposed overlay infrastructure are: i) a central controller that monitors the underlay network status and determines new paths in case of a failure, ii) the egress points that are responsible of routing the traffic flows leaving a Data Center toward the most appropriate ISP, and iii) the routing inflection points that are special nodes that manage the routing between two distant Data Centers, by using SR encapsulation.

\cite{li2017segment} proposes the use of SR in an hybrid IP/SDN network as a technique to mitigate the problem of the limited storage space in the flow tables of the SDN switches.
The main goal is to use SR to optimize the use of the flow tables and the link capacity.
In the considered scenario, every node supports both OpenFlow operation and normal IP switching operation.
When a packet enters a node, first it is classified in order to decide through which pipeline it has to be steered, then it is processed accordingly.
Operations associated to the normal IP pipeline are decided using a routing protocol (eg. OSPF).
Differently, the path to be followed by traffic flows steered through the OpenFlow Switching Layer (OFSL) are decided by the central SDN controller.
In order to limit the number of flow entries to install in order to configure a path, SR is exploited.
In this way, a portion of the flow state information is moved from the flow table of the switches to the packet header.
In order to insert the SR related information, i.e., the segment list, in the packet header, \cite{li2017segment} proposes to use unused fields (eg. VLAN tag or optional fields).
%Moreover, also the concept of port based SR forwarding is defined: a path is expressed as the sequence of ports that it has to traverse.
%To cope with the limited space available to write the segment list, this last is divided in sub portions.
%Then, at the ingress point, the first portion of the segment list is inserted in the packet header, and the forwarding operation is performed accordingly. 
%When this first sub path is completed, then an intermediate node, called loading node, remove the old portion of segment list and add the next one.
%Finally, \cite{li2017segment} proposes an optimization framework to balance the use of the TCAMs and the bandwidth in the network links.

Software Resolved Networks (SRNs) is a new SDN architecture recently proposed for IPv6 enterprise networks \cite{lebrun2018software}\cite{duchene2018exploring}; further details about the implementation are provided in the Section \ref{sec:tools}. The network is managed by a logically centralized controller which interacts with the end-hosts through an extended DNS protocol: applications are allowed to embed traffic and/or path requirements in their requests and the controller is able to return the appropriate path to the applications satisfying their needs. SRv6 is used as data plane technology to steer the traffic on a specific path according to the network policies. Each component that can be reached through the network is always referenced through a DNS name. The default DNS resolver in the hosts is modified to interact with the controller of the architecture. SRN provides also a mechanism for the dynamic registration of the end-points. In this way, the DNS database can be properly updated and the name resolution can be performed by the clients. The connections are always unidirectional so it is necessary to establish two paths in order to enable the communication between the endpoints. Binding segment is used to implement a path id and it is automatically translated in a SRv6 policy in the access node. Path segmentation is performed using the algorithm illustrated in \cite{scmon} which allows to match a given policy and guarantee the minimal list of segments. In order to optimize the interaction with the controller, upon a request the controller computes the two paths to support the communication and then instruct the access device of a node to add also the reverse binding segment in the SRH. In this way, the reply can be simply echoed back. Software Resolved Network has been implemented on Linux end-hosts, routers and controllers. %Through benchmarks and simulations, several aspects of the architecture are analyzed. In particular, the authors analyze the completion time of the requests under different conditions and network settings. Moreover, the authors provide also an analysis of the reaction time to link failures.

In \cite{ventre2018sdn} a novel SDN architecture is proposed for SRv6 technology; Section \ref{sec:tools} provides further information about the implementation and where is possible to download the code. The data plane is constituted by Linux based SRv6 nodes built from open source components which expose an open API towards the SDN controller. The nodes result to be hybrid as they envisage the coexistence of a legacy IP control plane with an SDN control plane. The authors present the design and implementation of the Southbound API between the SDN controller and the SRv6 devices which is used to instantiate SRv6 policies in the network. In particular they propose a data-model and provide four different implementations of the API, respectively based on gRPC, REST, NETCONF and remote Command Line Interface (CLI). Topology discovery is also addressed actively extracting the topology database from the IP routing daemons running in the network nodes. %In addition the authors, to support both the development and testing aspects, have realized an Intent based emulation system to build realistic and reproducible experiments relieving the experimenters from a huge configuration effort. Finally, they have evaluated the performance of the Southbound API implementations under different settings and network conditions. Moreover, they have analyzed the effects of the configuration updates in the SRv6 enabled nodes showing that is possible to achieve hitless reconfiguration of SRv6 policies.

A hierarchical multi-domain control plane for SDN networks based on SR has been demonstrated in \cite{demonstrationofsr}. The control plane is composed by an orchestrator application which runs on top of multiple SDN controllers and leverages their NB APIs to create multi-domain SR based services. BGP-LS and PCEP are used as southbound in the SDN controllers and provide respectively network topology and the creation of MPLS SR tunnels. IS-IS is used inside the domain to exchange reachability information and SIDs between nodes. SDN controllers do not exchange any reachability information nor SIDs. Orchestrator interacts with the SDN controllers and builds a global network view that will be used to perform the path computation and to instantiate SR services. A practical demonstration has been realized using software routers. 
%In particular, the data plane is emulated using Cisco virtual routers (xRV) and OpenDayLight has been deployed as SDN controller in each domain. 
%Due to some practical limitation in the discovery of the inter-domain border routers another controller is deployed to manage them. 
%The authors implement an ECMP use case leveraging Prefix-SIDs and an application aware TE module where bandwidth and delay constraints can be specified by the applications. Using this information, the orchestrator finds suitable paths composed by links that meet the specified requirements. Finally, a multi-domain use case is illustrated where the scalability of the approach is demonstrated.

In \cite{experimentalmulti} two solutions for multi-domain SR are proposed: end-to-end Segment Routing and per-domain Segment Routing. Both methods leverage a non-standard east/west interface between peer controllers, thus rely on a flat control-plane architecture and do not use signaling sessions in the data plane. In the first approach, the segment list contains already the end-to-end path crossing several domains. The originator domain sends a request to the destination domain. The destination controller computes the segment list to reach the destination from its ingress router and sends it back to the previous domain. Each intermediate domain applies the same procedure stitching the segment list computed by the downstream until the reply is received back by the originator. Conversely in the second approach, the end-to-end path is obtained stitching several SR paths: in each domain the segment list contains a virtual label as bottom of the stack which triggers a modification of the segment list in the ingress border node of the next domain. In this case, there is no global view of the network, and controllers do not know the domain sequence to reach destination. \revnew{Scalability of the proposed schemes is evaluated in terms of segment list depth. Results show that per-domain SR is able to encode 60\% of the paths using at most 3 labels while end-to-end SR just the 12\%. In general, the average SL depth is 5.34 and 3.36 respectively for end-to-end SR and per-domain SR.}

\cite{evolve} proposes an advance of Carrier Ethernet architecture and envisages an approach mixing SR and SDN technologies. It results to be a trade-off between fully-distributed control planes and centralized approaches: an inventory database is maintained into the SDN controller with the configuration for each device. The SDN controller provides the IP configuration and SR configuration like the loopback address, node label, label range, gateway label information via a southbound API like NETCONF/Yang. For any communication inside the domain by design the network will use the IGP based forwarding without the need of the SDN controller and will impose on the traffic a single MPLS label (loopback SID). 
Multiple labels can be used to realize TE applications.
Instead, in a multi-domain scenario several SDN controllers are deployed and exchange reachability information in order to properly program the edge nodes. In this way an inter-domain path can be established simply with a label stack that includes local and remote border router labels, plus the end node label. 
%The network nodes do not need to keep the label or a prefix outside of its domain. Only the SDN control plane has the information for all network nodes. Finally, the authors envisage the introduction of the services SID for SR to redirect flows to a particular network service, which can be a Virtual Network Function or an application running into the Cloud DC.
\revnew{Similarly to other works, further analysis is not possible as the code of the control plane is not open source and as for the data plane, the solution relies on Carrier Ethernet hardware.}


\revnew{Busoni \cite{barakat2019busoni} is an orchestration framework for Segment Routing based networks, which automates and simplifies many aspects of the network management. From an architectural standpoint, Busoni sits on top of a SDN controller and benefits of the information exported by the controller to feeds its data-store. The latter is a graph database and it is used to persist data. In particular, Busoni leverages it to keep track of the SIDs advertised in the network, the installed policies, and to respond to any dynamic event. The framework provides users with programming tools to compose and manage SR policies and operates efficiently, even under multi-tenancy environments. Finally, Busoni updates automatically the nodes and the edges of the graph database whenever there is an update in the network and reflects these changes on the installed policies; this allows to keep them resilient to dynamic events.}

\revnew{\cite{eramo2019effectiveness} proposes a scalable centralized controlled architecture for the management of the SFC Routing and Cloud Bandwidth resource Allocation (SRCBA), that is based on SR.
The proposed solution is thought to be applied in a multi domain scenario, where a transport network interconnects a set of private cloud infrastructures, possibly owned by different provides.
In particular, instead of using classical approaches to solve the SRCBA problem, which require a detailed knowledge of either the transport network and the cloud infrastructure, the proposed architecture exploits the BSID concept to abstract the services provided by a single cloud infrastructure to the external network.
The resulting Orchestrator is then divided into two logical components: i) a centralized Network Service Orchestrator (NSO), which is in charge of collecting the SFC requests and manage the bandwidth in the transport network, as well as, decide what datacenter assign the processing of the incoming requests, ii) and a set of local Resource Orchestrators that are in charge of managing the network and cloud resources in the context of a single infrastructure.
In this way, the centralized NSO can rely on summarized information to take decisions while solving the SRCBA problem.
This allows for a great reduction of the computation time, while assuring comparable performance in terms of efficiency in the use of the resources.
}

\revnew{In the following we provide a comparison among the works classified in the \emph{Centrally Controlled Architecture} category.}

\revnew{An interesting aspect to compare the research works falling into this category is related to the way they use SR. For instance, some solutions exploit SR to overcome some limitations existing when other technologies are adopted. Other centrally controlled architectures make use of SR to realize specific functions, that resulted to be more complex relying on other paradigms. Finally, some works falling into this category have the goal of proposing an implementation and provide a demonstration of the feasibility and the performance achieved.}

\revnew{Among the works that exploit SR to overcome limitations of other existing approaches there are \cite{paolucci2018network,li2017segment,barakat2019busoni,eramo2019effectiveness}. Specifically, in \cite{paolucci2018network} SR allows to reduce the complexity of configuring and updating the path for an incoming SFC request, thanks to the adopted source routing paradigm. In \cite{li2017segment} exploit the same principle to show that, by adopting SR, the stringent TCAM size constraint can be overcome. Finally, \cite{barakat2019busoni} proposes an orchestration framework to simplify the policy management. Similarly, \cite{eramo2019effectiveness} proposes a scalable centralized controlled architecture for the management of the SFC Routing and Cloud interconnect bandwidth allocation.}

\revnew{Different functions at the network level are realized in centrally controlled architectures proposed in \cite{experimentalmulti,castoldi2017segment,fressancourt2015sdn}. As an example, in \cite{experimentalmulti} SR is used to realize an optical bypass, while it is exploited to overcome node and link failures in \cite{castoldi2017segment}. Finally, an overlay network to interconnect geographical distributed DCs is realized through SR in \cite{fressancourt2015sdn}.}

\revnew{As previously stressed, the aim of some of the works falling in the \emph{Centrally Controlled Architecture} category is to propose possible implementations of SR, and to provide a demonstration. This is the case of \cite{ventre2018sdn,springopen,demonstrationofsr}. In \cite{ventre2018sdn}, SRv6 nodes based on the linux implementation are considered in the data plane, while the other works are focused SR-MPLS. Furthermore, \cite{demonstrationofsr} demonstrates how to build an end to end paths in a multi domain SR network, while in \cite{springopen} a single domain scenario is considered.}

\subsection{Path Encoding}
\label{sec:path}

The translation of a network path, resulting from a specific TE objective, into a sequence of SIDs, i.e. a Segment List, is a key operation for the deployment of SR in a real network. This operation is usually referred to as Path Encoding.
\PathencPapers different papers have been defined for the definition of a proper a solution to the path encoding problem.
The different algorithms differs depends on the nature of the network path, i.e. the path to be encoded.
Specifically, the input path might be computed on top of a network with uniform link weight or arbitrary ones.
Moreover, it might include ECMP or not.
A further aspect for the path encoding algorithms is the possibility of requiring additional device configurations, as the insertion of a new policy.
Finally, path encoding algorithms can differ depending on the possibility of encoding the input path with one or more SLs.
Table \ref{tab:path-encoding} shows the paper classification according to the aforementioned aspects.

\begin{table}
\centering
\caption{\\Classification of the references related to Path Encoding.}
\label{tab:path-encoding}
\begin{tabular}{|c|l|l|}
\hline
\multirow{4}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Path to be\\ encoded\end{tabular}}}                        & \textit{\begin{tabular}[c]{@{}l@{}}uniform\\ IGP weights\end{tabular}}   & \cite{experimentaldemonstration},\cite{efficientlabel},\cite{pathencoding} \\ \cline{2-3} 
                                                                                                              & \textit{\begin{tabular}[c]{@{}l@{}}arbitrary\\ IGP weights\end{tabular}} & \cite{labelencoding},\cite{pmsr},\cite{translating},\cite{liaoruo2018optimizing},\cite{guedrez2017new} \\ \cline{2-3} 
                                                                                                              & \textit{\begin{tabular}[c]{@{}l@{}}ECMP\\ not allowed\end{tabular}}      &  \cite{pmsr},\cite{experimentaldemonstration},\cite{pathencoding},\cite{labelencoding} \\ \cline{2-3} 
                                                                                                              & \textit{\begin{tabular}[c]{@{}l@{}}ECMP\\ allowed\end{tabular}}          & \cite{efficientlabel},\cite{translating},\cite{liaoruo2018optimizing},\cite{guedrez2017new} \\ \hline
\multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Requires \\ further configuration\end{tabular}}} & \textit{no}                                                              & \begin{tabular}[c]{@{}l@{}}  \cite{experimentaldemonstration},\cite{efficientlabel},\cite{pathencoding} \\ \cite{labelencoding},\cite{pmsr},\cite{translating}\end{tabular} \\ \cline{2-3} 
                                                                                                              & \textit{yes}                                                             &  \cite{liaoruo2018optimizing},\cite{guedrez2017new} \\ \hline
\multirow{2}{*}{\textbf{Encoded path}}                                                                        & \textit{single SL}                                                       & \begin{tabular}[c]{@{}l@{}} \cite{experimentaldemonstration},\cite{efficientlabel},\cite{pathencoding},\cite{labelencoding} \\  \cite{pmsr},\cite{liaoruo2018optimizing},\cite{guedrez2017new} \end{tabular} \\ \cline{2-3} 
                                                                                                              & \textit{multiple SLs}                                                    & \cite{translating}                                              \\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as Path Encoding related works.

In \cite{experimentaldemonstration}, SDN and PCE based implementations of SR controller share a common path engine, that performs the hop-by-hop path computation and SR path assignment. As regards the path computation engine, the controller selects the least congested path on a set of candidate paths. Then, the proposed SR path assignment algorithm provides the shortest Segment list considering a unique path towards the destination and avoiding load balancing through ECMP. The algorithm uses two pointers $i$ and $j$ to navigate the target path from source to destination. Firstly, $j$ is incremented until the considered sub-path is no more a unique shortest path. At this point, the SID of the node $j-1$ is inserted in the Segments list and the two pointers are both set to $j-1$ and the procedure restarts. This cycle is repeated until the node $j$ is equal to the destination. The algorithms provides the segment list of minimum depth but the solution only considers global Node-SID therefore it cannot be applied to topologies with arbitrary IGP link costs.

The authors of \cite{efficientlabel} propose a Segment list encoding algorithm to express a given path, which minimizes (enforcing a give threshold) the Segment list depth in SR-based networks. It considers ECMP forwarding by default, but can also introduce constraints to support a deterministic hop-by-hop path. Respect to other efforts \revnew{((like \cite{pmsr})}, the solution is not able to support arbitrary hop-by-hop paths when arbitrary IGP link costs are used. 
\revnew{The core of the algorithm consists in the creation of a graph, whose arcs model SR related instructions (node and adjacency SIDs). Specifically an arc connecting two nodes represents the shortest path in the original network between the same pair of nodes.} 
\revdel{The algorithm is based on graph computation.} 
The so called auxiliary graph is built firstly using the physical links of the paths which are computed by an external TE heuristic, subsequently virtual links are added representing the ECMP paths between two nodes. Each virtual link is annotated with the metrics and the number of the ECMPs between the two nodes. Using this auxiliary graph a new path computation is performed adding a new constraint related to the number of hops: each path having a number of hop greater than the maximum Segment list depth is rejected. Then the candidate paths are sorted first according to their original metrics, second according to their length and then according to the number of ECMPs. Finally the paths are translated in SIDs using this approach: physical links are changed with their respective Adjacency SID, virtual links are mapped with the Node SID of the destination node. If the Adjacency SID are not local the algorithm first insert the Node SID of the source and then the Adjacency SID. 

\cite{pathencoding} proposes two algorithms for the computation of segment list which result to be optimal in terms of stack depth when an unique hop-by-hop path has been computed. Key idea is to consider at each iteration bigger sub-paths and verify if an unique shortest path exists, substitute the sub-path with the tail node SID and then move to the remaining part of the path. The algorithms are very similar, main difference is how to vary the breadth of the sub-paths until considering the original hop-by-hop path. The first algorithm navigates the target path starting from the source node toward the destination, while the second one leverages the opposite direction. The analysis of the overhead in the packet headers shows that reverse algorithm introduces less overhead compared to the direct algorithm, as the computed segment list typically includes nodes that are near the source. 
%The authors demonstrate that there is not a direct relation between segment list depth and number of nodes. Instead, there is a linear relation with the average length of the shortest paths. Finally, the analysis of the percentage of the paths encoded with different depths show that more than 90\% of the paths can be encoded with less than 4 SIDs.
\revnew{Other works (for example \cite{trafficpmsr, pmsr}) share the same objective of reducing the overhead of the packet headers but with respect to the solutions described above they start from the original hop-by-hop path and then evaluate the sub-paths reducing at each iteration the breadth.}

Also in \cite{labelencoding}, two algorithms for an efficient paths encoding, the so called SR-LEAs, are proposed. The algorithms take as input an explicit shortest path and then compute the relative segment list having as constraint a given maximum segment list depth. They are composed by two main steps: i) computation of successive shortest paths; ii) labels replacing. Specifically, they compute the subpaths of the original shortest path and take into account the limitation of the hardware to reduce the number of the subpaths. In the second step, the subpaths composed of three or more nodes are replaced by the Node-SID of their tailnode. SR-LEA replaces two nodes subpaths using the Adj-SID. The variant SR-LEA-A is very similar to the above algorithm but takes advantage of the global Adj-SID to further reduce the depth of the labels stack. Of course, it requires the advertisement of these SIDs to properly work. Simulation results show that the algorithms are able to compute segment lists with an average length lower than 3. SR-LEA-A delivers best results and can improve the segment list computation compared to SR-LEA but the gain is around 5\% in terms of average length.
%An analysis of the percentage of the doable paths shows that using at most 5 segments the designed algorithms can implement in the worst case 97\% of the paths.

The authors of \cite{pmsr} propose an optimal SR path assignment algorithm and prove that it is optimal in terms of the number of used segments. The algorithm takes as an input an hop by hop path computed by a TE heuristics and computes an SR path congruent with the one calculated by the heuristic and composed by a minimum number of segments. 
%The work builds upon the results of \cite{trafficpmsr}. 
The SR assignment algorithm evaluates at each iteration if it exists a shortest path between the current source and the current destination, and then each time considers different subpaths updating the current source or the current destination. 
%Going into details, it starts evaluating the shortest path between the source and the destination of the path and it evaluates if it exists an unique shortest path. If yes the node segment of the destination is pushed in the segment list and it exits. Otherwise, it consider as current destination the node preceding the destination and a new iteration is started. 
Each time a new segment is found the current source is updated with the previous destination and the current destination is substituted by the destination of the original hop-by-hop path. In the worst case, the link between the current source and its next hop is evaluated, if the link is different from the shortest path an adjacency segment is pushed in the segment list. 
%Performance evaluation shows algorithms computational complexity is negligible and it is possible to achieve sub-second processing time also with high number of flows to be mapped .

%In \cite{translating} the Segment List encoding problem, i.e. the problem of selecting the proper Segment Lists able to implement a specific Traffic Engineering (TE) path, is faced.
The authors of \cite{translating} propose a two-steps method for translating a given Traffic Engineering (TE) path into an SL. In the first step, an auxiliary graph is created; the aim of the auxiliary graph is to represent all the Interior Gateway Protocol (IGP) paths available, i.e. forwarding paths, for the specific TE path to be encoded. In the second step, a MILP problem over the auxiliary graph is defined: the MILP problem allows minimizing the overall Segment List length given the target TE path. One of the main features of the propose solution is the multi-path support, i.e. the ability to split a source-destination flow among a weighted set of segment lists. 
%The performance evaluation shows that the proposed solution allows to greatly reduce the SL lengths with respect to a benchmark explicit solution, i.e. an encoding strategy where a SID for each crossed node is inserted in the SL. %Moreover, the encoding solution proposed also outperforms the End-to-End solutions, i.e. the MPLS one, in terms of number of SL/tunnels needed: this result is mainly due to the ability of SR to exploit equal cost multipath available at forwarding level.

%SR allows to steer packets along non trivial paths, by properly writing segment lists to be pushed on the SR packet header.
%Clearly, the more complex is the path, the longer the segment list will be.
In \cite{liaoruo2018optimizing} the problem of optimizing the performance of an SR network under the maximum Segment List Depth (max-SLD) constraint is studied.
In fact, especially when SR is realized on top of the MPLS data plane, the constraint on the max-SLD is particularly limiting.
A possible solution is to create new LSPs, so that to increase the availability of alternative paths in the underlay network, and consequently being able to write shorter segment lists.
Despite the creation of new LSPs allows reducing the length of the segment lists, its main drawback is the increase of the number of required forwarding rules to be installed in the routers forwarding tables.
In order to mitigate this negative effect, \cite{liaoruo2018optimizing} defines the concept of panel based forwarding: a panel refers to a set of node-disjointed LSPs that can be represented by the same label.
Furthermore, an ILP formulation is proposed to solve the path encoding problem, minimizing both the number of new defined LSPs and the installed rules, while respecting the max-SLD constraint.

%When a complex path is encoded by means of a list of segments, the depth of the resulting SL might be high.
%Depending on the considered data plane, there is a limit on the number of SIDs that can be stacked on a SL, named Maximum Stack Depth (MSD).
%For instance, in case of SR-MPLS this limit ranges between 5-10 SIDs per SL.
%When the considered path cannot be encoded with an SL shorter than the MSD, then a different path has to be searched.
To overcome the Maximum Stack Depth (MSD) constraint in SR-MPLS, a new type of SID, named Targeted SID (TSID), is defined in \cite{guedrez2017new}.
A TSID is a local segment that is associated with a sequence of SIDs. 
The instruction related to a TSID consists in replacing it in the SL with the associated sequence of SIDs.
By using a TSID, it is possible to reduce the length of an SL, at the cost of introducing a new flow state in the node that implements the instruction related to the TSID.
For this reason, \cite{guedrez2017new} proposes two different optimization problems that allows to find a trade-off between the benefits and the costs of the implementation of the TSIDs.
The first optimization problems takes as input the set of paths whose related SL overcomes the MSD bound, and aims at minimizing the number of defined TSIDs. 
The focus is then the reduction of the number of extra flow states to be maintained by the network nodes.
A second optimization problem is presented, with the goal of minimizing the PCEP sessions that has to be maintained between the central controller (responsible for the TSID installation) and the nodes where the TSIDs have to be installed.
In this case, the main idea is to install as many TSIDs as possible in the same node.

\revnew{A possible key to compare the existing SL encoding techniques, is to focus on the method they use to get the final list of SIDs.
In particular, two different methods are exploited. The first one is based on the Bellman-Ford principle, which states that each sub path contained into a shortest path, it is itself a shortest path. Starting from this consideration, these algorithms explore the path to be encoded, starting from the source node up to an intermediate one.
Until the path between the source and the intermediate node is found to be a shortest path, they move on by considering the next node in the path.
When this condition does not hold, the first SID is found.
The process goes ahead until the full path is explored.
SL encoding tools presented in \cite{pmsr,experimentaldemonstration,pathencoding,guedrez2017new} use this approach. 
Furthermore, it is interesting to emphasize that all the works using this approach do not allow the use of ECMP in the underlay.}

\revnew{The second type of approach consists in the creation of an auxiliary graph to represent the underlay paths.
Specifically, an arc of the auxiliary graph is an entire path in the underlay.
This type of approach is used in \cite{efficientlabel,translating}.
The main difference between the solutions presented in these two works is that, in \cite{efficientlabel} the end to end path is encoded by applying the Dijkstra algorithm over the auxiliary graph, while in \cite{translating} the problem is modeled as a Multi Commodity Flow over the auxiliary graph. As a consequence \cite{translating} also allows the use of multiple SLs to steer a single flow.}

\subsection{Network Programming}
\label{sec:netprog}

Despite the fact that Network Programming is the most attractive and innovative feature of SR, we have found only \networkProgPapers papers related to this topic.
As shown in table \ref{tab:network-programming}, these works can be classified in Service Function Chaining related ones, or operational function.
The latter aim at implementing operational functions, such as \revnew{a firewall, }a load balancer and a zero-loss VM migration tool, by exploiting the network programming feature of SR.

\begin{table}
\centering
\caption{\\Classification of the references related to Network Programming.}
\label{tab:network-programming}
\begin{tabular}{|c|c|}
\hline
\textbf{\begin{tabular}[c]{@{}c@{}}Service Function\\ Chaining\end{tabular}} & \cite{mayer2019efficient},\cite{srv62},\cite{17-vnf-chaining-sr},\cite{duchene2018srv6pipes},\revdel{\cite{abdelsalam2018sera}} \\ \hline
\textbf{Operational Function}                                                & \revnew{\cite{abdelsalam2018sera}},\cite{srlb},\cite{desmouceaux2019content},\cite{desmouceauxzero} \\ \hline
\end{tabular}
\end{table}

In the following we provide a brief overview of the references classified as Network Programming related works.

%In \cite{srv61} the implementation of SRv6 in the Linux kernel is described. The implementation provided is composed of three architectural elements: the forwarding module, ii) the routing and encapsulation module, and iii) the user-facing module. The forwarding module allows to identify SR packets and to forward them to the routing module, responsible for encapsulation or header insertion. The routing module is realized using Lightweight Tunnels, available in the Linux Kernel. The user-facing module allows the applications to control the SR data, i.e. defining the proper SR headers to be inserted, and is implemented using the NETLINK API. The performance evaluation shows that even for very low packet size (i.e. 64 byte) the performance degradation due to extra operation of SRv6 is limited. The author also proposes a use case for a service to be deployed exploiting SR functionalities: the parental control running on a Customer Provider Equipment (CPE) on the basis of MAC addresses. 
In \cite{srv62} the Linux SRv6 implementation described in \cite{srv61} is enhanced introducing the support for Service Function Chaining. More in detail, the Linux kernel provides an API to map a service segment, i.e. the identifier of a network service running on a Virtual Machine. The experimental evaluation show that the impact of SR operations and service segment processing on the packet forwarding capabilities is limited, i.e. with a reduction lower than $10\%$.

The architecture of a network domain supporting Service Function Chaining (SFC) through SRv6 is investigated in \cite{17-vnf-chaining-sr}.
The authors mainly focus on the implementation of a VNF node able to host multiple VNF instances. The main components of the VNF nodes are the SR/VNF connector, in charge of logically connecting the SR routing with local VNFs, and the VNFs, supporting a specific network functions. The VNFs can be SR-aware or SR-unaware: i) SR-aware VNFs can process the
information contained in the SR header (SRH) of incoming packets; ii) SR-unaware VNFs are not able to handle the SRH thus, in order to correctly apply the VNF to the original packet, the SR/VNF connector must pre-process the packet by removing the SR encapsulation, and re-apply it when the packet is returned by the VNF.
The authors propose a Linux-based implementation of a VNF node supporting both SR-aware and SR-unaware VNFs. More in detail, using the netfilter framework, a new kernel module called srext (Segment Routing EXTensions) is implemented to act as a SR/VNF connector and support SR-unaware VNFs.
A virtualized testbed based on Virtualbox ang Vagrant is realized to evaluate the processing overhead introduced by the proposed implementation with respect to a classical IPv6 forwarding solution. %The experimental results shows that the performance degradation is very limited: the proposed implementation has a fixed CPU processing overhead of $3.6\%$, while the additional processing cost, depending on the packet rate, is in the order of $2\%$.

SRV6Pipes \cite{duchene2018srv6pipes} is an extension of the IPv6 implementation of Segment Routing in the Linux kernel which enables chaining and operation of in-network functions operating on streams. SRv6 is used to enforce an end-to-end path between the client and the server passing through the equipment hosting the networking functions. 
%SRv6 policies are installed using the SRN architecture \cite{lebrun2018software} described in Section \ref{sec:hybrid}. 
The rationale behind SRv6Pipes stands in the fact that some network functions need to include a TCP implementation to work on the streams. SRv6Pipes leverages ``the TCP stack that is already present in the Linux kernel'' and implements a transparent TCP proxy to offload to it the TCP functionalities and terminates the TCP connections where a network function is deployed. In this way, it is possible to expose to the network functions the bytestreams they need to process. Special addressing is used to specify network functions and their parameters. In particular each proxy exposes an 80 prefix. The first 80 bits are used to traverse the proxy, the following 16 bits are used to identify the network function and the remaining ones are used to specify the parameters of the function. %The performance evaluation compares the SRv6Pipes architecture with a Linux router under different experiments showing that there is no performance loss introducing a TCP proxy in the path. Similar results are obtained chaining two proxies. Finally in another experiment, the impact of the VNF processing on the maximum throughput is analyzed.

\cite{abdelsalam2018sera} defines the concept of SR Aware VNF, as an application that is able to process the SR information in the packet.
Moreover, \cite{abdelsalam2018sera} also proposes the implementation an SR Aware (SERA) Firewall application.
The SERA Firewall is able to work both as a legacy firewall (basic mode), or define filtering rules that also include condition on the SR fields (advanced mode).
In the basic mode, it can apply the normal firewall processing to the original packets even if they have an SR based SFC encapsulation.
It means that the filtering rules are applied to the original values of the packet header (the SR related fields are transparent).
In the advanced mode, SERA offers new matching capabilities and new SR specific actions that allow to modify fields in the SR Header. 
%Some examples are the \emph{seg6-go-next}, which sends the packet toward the next segment in the SL, the \emph{seg6-skip-next} which allows to skip the next SID in the SL, or the \emph{seg6-go-last} which sends the packet directly to the last SID of the SL.

Segment Routing Load Balancing (SRLB) \cite{srlb} is an Application-aware load-balancer that avoids the cost due to the monitoring tasks.
It is thought to work in the contest of a Data Center network, where several instances of the same application are instantiated in different hosts machines.
Each host machine is equipped with a VPP based virtual router which dispatches packets between physical NICs and application-bound virtual interfaces.
The Load Balancer (LB) is located at the edge of the Data Center network.
A request for an application is represented by the first packet sent from the client to the application server (generally a syn message). 
When a new request arrives at the LB, the Service Hunting function, which consists in finding a server that can serve the current request, is executed.
LB exploits SR to query a subset of servers that host the requested application.
Specifically, LB encodes the set of randomly selected potential servers in the segment list, then encapsulates the first packet of the request.
When the first server receives the packet, it can decide whether to deliver it to the application, and consequently assign to it the processing of this request, or can forward the packet to the next server in the segment list.
The decision about accept/refuse a request is taken according to a connection acceptance policy, that takes into account the internal state of the application (CPU usage, memory usage, etc.).

\cite{desmouceaux2019content} proposes a new architecture for the Content Delivery Networks (CDNs) building upon the results of \cite{srlb}. In this new paradigm, CDN decisions (cache vs origin servers) are offloaded to the data plane. This architecture founds on two fundamental pieces: i) chunk-level content addressing and ii) in-network server selection. The first is realized assigning a unique and globally routable IPv6 address to each chunk. Instead, the in-network server selection leverages these identifiers exposed as IP addresses to make in-band forwarding decisions which are later binded to a SRv6 steering policy. In particular, upon arrival of a request at a CDN proxy, the IPv6 identifier is used by the prediction engine to perform cache admission by estimating the popularity of requests with a Least-Recently-Used (LRU) filter. If not available (cache miss), 6LB \cite{srlb} is used to forward requests directly to the origin servers instead of proxying them at the cache. According to the authors, this mechanism allows to reduce the load on the edge cache and avoid the negative effects on the Quality of Experience.

%Virtual Machine (VM) migration is a fundamental primitive that is widely exploited in Data center networks to optimize the Capex/Opex.
%For a network perspective, a challenging task is to allow live migration of VMs while keeping connectivity.
%In fact, during the downtime, i.e., when the migrated VM is not working neither in the old nor in the new host machine, packet loss can occur, as well as, network connectivity might be lost.
\cite{desmouceauxzero} proposes an SR based live migration technique which achieves zero packet loss.
The starting point is an SRv6 enabled Data center network.
Two new SR functions are defined and used in the process of VM live migration.
The first one is \emph{forward to local if present}, which is a conditional version of the END behavior described in section~\ref{sec:sr_net_prog}. Specifically, in case the last SID in the SL is locally available, then the packet is directly processed, thus ignoring possible intermediate SIDs.
The second one is \emph{buffer and forward to local}, that forces the node to inspect the last SID and, in case it is not locally available, the packet is buffered until the SID becomes available.
Now, assuming that a VM is migrated from host A to host B, then during the migration process all the requests received by the Data center gateway are tunneled using an SL where: i) the first SID points at the \emph{forward to local if present} function implemented at A, ii) the second SID points at the \emph{buffer and forward to local} function implemented at B, and iii) the last SID is referred to the VM.
In this way, until the VM is available at A, the packets are directly delivered to the VM thanks to the \emph{forward to local if present} function. Then, during the downtime, the packets directed to the VM are buffered at B thanks to the \emph{buffer and forward to local}. Finally, when the VM becomes available at B, the buffered packets, as well as new arrivals, are directly delivered to the VM at B.
In this way it is possible to implement VM live migration having no packet loss.

SRNK \cite{mayer2019efficient} is a SR-proxy for legacy VNFs which are not aware of the SRv6 technology and expect to process traditional IP packets. SRNK extends the implementation of SRv6 in the Linux kernel \cite{lebrun2017implementing} adding the support for the \textit{End.AS} and \textit{End.AD} behaviors. The performance of the proposed solution has been evaluated by the authors which identified a poor scalability with respect to the number of VNFs to be supported within an NFV node. With an enhancement of the Linux Policy Routing framework, they provided a second design SRNKv2, which does not depend on the number of supported VNFs in a node. They compared the performance with a reference scenario not performing the encapsulation and decapsulation operation and demonstrated that the overhead of SRNKv2 is very small, on the order of 3.5\%.

\revnew{\cite{srv62, 17-vnf-chaining-sr, duchene2018srv6pipes, mayer2019efficient} have in common the Service Function chaining topic. At the same time, there are some important differences that have to be highlighted. \cite{srv62} adds an API in the SRv6 implementation of the Linux kernel to map the service segments. It mainly deals with SR-aware VNFs. Instead, \cite{mayer2019efficient} proposes a SR-proxy for SR-unaware VNFs. \cite{17-vnf-chaining-sr} implements a solution able to deal with both SR-aware and SR-unaware VNFs but with respect of the previous works it extends the netfiler framework, while the previous solutions are extensions of the SRv6 implementation in the Linux kernel. 
Finally, \cite{duchene2018srv6pipes} is still an extension of the SRv6 implementation in the Linux kernel but it the enables chaining of in-network functions operating on streams, thus it works at a higher level (Transport layer) with respect to the previous works.}

\subsection{Performance evaluation}

\revnew{In this subsection, we report \perfevalPapers papers dealing with the performance evaluations of SRv6 implementations.}

SRPerf \cite{ahmedperformance} \revnew{\cite{abdelsalam2020srperf}} is a performance evaluation framework for software and hardware implementations of SRv6. SRPerf is able to perform different benchmarking tests such as throughput and latency. At the time of writing, the framework supports \revdel{only} Linux kernel \revnew{and VPP} implementation\revnew{s} of SRv6. The architecture of SRPerf can be easily extended to support new benchmarking methodologies as well as different SRv6 implementations. The framework supports two different metrics to characterize the throughput of a SRv6 enabled node: No-Drop Rate (NDR) and Partial Drop Rate (PDR). PDR is defined as the highest throughput achieved without dropping packets more than a predefined threshold; NDR\revnew{, which corresponds to the Throughput defined by RFC 1242~\cite{rfc1242},} can be described as PDR with threshold of 0\%. The framework orchestrates all the aspects of an experiment starting from the setup of the testbed up to the enforcement of the SRv6 configurations, relieving the experimenter from a significant configuration effort. SRPerf has been used to evaluate the performance of the SRv6 implementation\revnew{s} in the Linux kernel \revnew{and in VPP}. \revnew{Moreover in \cite{abdelsalam2020srperf}, the authors propose the evaluation of an enhanced Linux kernel, which has been obtained by adding the implementation of missing behaviors and fixing the implementation of existing ones.}

\revnew{\cite{teamsegment} presents a solution where low-level network functions such as SRv6 encapsulation are offloaded to the Intel FPGA programmable cards. In particular, the authors partially offloads the SRv6 processing from VPP software router to the NICs of the servers increasing data-path performance and at the same time saving resources. These precious CPU cycles are made available for the VNFs or for other workloads in execution on the servers. Tests results of the \textit{End.AD} use case show in the worst scenario a CPU saving of 67.5\%. Moreover, the maximum throughput achievable by a pure VPP solution with 12 cores is achieved by the accelerated solution by using only 6 cores.}

\revnew{\cite{leeperformance} studies SRv6 as alternative user plane protocol to GTP-U \cite{gtpu}. Firstly, the authors proposes an implementation of the GTP-U encap/decap functions and of the SRv6 stateless translation behaviors defined in \cite{id-srv6-mobile-uplane}. These behaviors guarantee the coexistence of the two protocols which is crucial for a gradual roll-out. The authors used programmable data center switches to implement these data plane functionality. Since it is hard to get telemetry from commercial traffic generator when a translation takes place, the authors injected timestamp with a resolution of nanoseconds to measure the latency of SRv6 behaviors. Finally, they measured throughput and packet loss under light and heavy traffic conditions on a local environment. Results show no huge performance drop due to the SRv6 translation. Moreover, the latency of the SRv6 behaviors is similar to the GTP-U encap/decap functions.}

\subsection{Miscellaneous}

\revnew{In this section we included all the works not belonging to previous categories. In general, these works are very different among them and have in common only the Segment Routing topic.}

\cite{abdullah2018segment} provides a tutorial on Segment Routing and a survey on research activity covering more than 50 scientific papers. The tutorial part focuses on the SR-MPLS data plane part and does not consider the recent SRv6 data plane. SR standardization efforts, implementation activities and deployments are not specifically analysed in \cite{abdullah2018segment}.

Even if Control Exchange Point \cite{cxp} does not explicitly leverage SR, it proposes the concept of \textit{pathlets} \cite{pathlet} which closely resembles to the idea of the list of instructions present in the SR architecture. Control Exchange Point (CXP) main goal is to provide services with QoS constraints across domains. This is achieved stitching the \textit{pathlets} which are partial paths advertised by the domains. An ISP abstracts its network as a set of \textit{pathlets} connecting the network edges and then advertises these on the northbound. More specifically, this abstraction is realized with tunnels instantiated with OF, MPLS, optical path and so on. The \textit{pathlet} abstraction is bundled with properties that the ISP provides like latency, costs, available bandwidth and so on. A CXP is an external entity acting as brokering layer and providing inter-domain routing coordination based on SDN APIs. The general idea seems to be inline with SR architecture presented so far and it can be implemented using SR data-plane technologies.

\cite{scalablesegment1}, \cite{scalablesegment2} and \cite{scalablesegment3} propose an alternative implementation of SR architecture through Omnipresent Ethernet (OE), which is a modification of Carrier Ethernet architecture. It is based on source-routed, binary-routed labels embedded in an Ethernet frame. \cite{scalablesegment3} provides details on the implemented SR header. 
%The authors address scalability issues of SR in the context of multi-domain scenarios from two different point of views: packet header size and the number of look-up table entries required at the edge nodes. In particular, they propose two schemes for OE architecture: i) hierarchical based solution and ii) flat domain based solution. The first solution requires partitioning of the network into sub-domains and selecting a higher level node within every cluster that is capable of the label-swap operations. This results necessary to implement the inter-cluster routing. According to the authors, this scheme can reduce the size of the routing-table at the edge nodes but can lead to non-shortest-path forwarding. This limitation is overcome by the second framework proposed by the authors, that assumes all nodes can be label-swap and the nodes belong to a single network-wide SR domain. The framework achieves shortest-path routing at the cost of increasing the routing-table maintenance at intermediate nodes. In the hierarchical solution, it is important the optimal selection of the stitching nodes, for this reason an integer linear program is defined and solved. Instead, for the flat architecture it is important to minimize the bit length vector of the source routed label which is equivalent to minimize the stack depth in the SR architecture. The authors define a second integer linear program and provides a solution allowing the computation of the optimal binary source routed label. The authors realize also a testbed to validate the implementation of the proposed schemes. In particular, they compare the schemes in terms of number of swap nodes, labels size, routing entries and many others.
\revnew{The authors of the aforementioned works address scalability issues of SR in the context of multi-domain scenarios from two different point of views: packet header size and the number of table entries required at the edge nodes. They realize also a testbed to validate the implementation of the proposed schemes. However, further analysis is not possible since the solution builds upon Carrier Ethernet hardware.}

\revnew{\cite{schuller2018practical} analyzes the TE problem for SR using a different angle: the authors evaluates the influence of the metrics used to define the cost of the links. Key findings of the study is that the routing metric can influence shortest path based TE. Very simple and reasonable metrics like the inverse capacity work as well as a complex optimized metric. They allow to be close to the optimum with respect to the most common traffic engineering objective of minimizing maximum utilization. Finally, if other objectives are introduced besides optimizing link utilization - the choice of the metric is more important and there are significance differences between the metrics. Although \cite{schuller2018practical} deal with Traffic Engineering, it does not provide a new heuristic nor a different way to address the problem, but it is just a study on the influence of the routing metrics, so we have not classified it in the TE category.}

\revnew{In \cite{chi2018live}, the authors take advantage of Segment Routing to build a SR based Multicast delivery mechanism to efficiently 
provide live video streaming services for 5G users. Segment Routing (SR) is used to alleviate the rule update overhead and avoid the explosion of routing tables in the devices. The work builds upon an interesting problem, however it does not provide a lot of details about the SR implementation. The work mainly focuses on the problem of building efficient Multicast tree to further reduce the rules update due to the user movements (Handover-aware Multicast tree).}

\revnew{\cite{cao-industrial-iot} considers an Industrial IoT (Internet of Things) scenario with an extremely large number of objects to be connected, also taking into account their mobility. The proposed solution relies on Segment Routing for enabling scalability and flexibility in packet forwarding and in particular to bypass the overloaded links and to achieve load balance.}

\revnew{\cite{mayer-network-as-computer} proposes a novel distributed processing model for the Iot, based on the extension of the SRv6 Network Programming Model. The idea is that each IoT node offers an abstract machine that can be programmed using an Instruction Set Architecture. The program can be embedded in an SRv6 segment list. An SRv6 packets carries both the program and the execution state. It can travel across IoT nodes, reading and writing the I/O ports of the device and executing computations as dictated by the program in the packet itself.}
